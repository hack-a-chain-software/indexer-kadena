/**
 * Transaction Model Definition
 *
 * This module defines the Transaction model, which represents blockchain transactions in the Kadena network.
 * It includes the core transaction data structure, relationships to other entities, and GraphQL schema
 * extensions for API access. Transactions are the fundamental units of blockchain activity,
 * containing information about state changes, transfers, and events.
 *
 * The model provides:
 * 1. Core transaction attributes and structure
 * 2. Database schema definition with indexes for efficient querying
 * 3. Relationship definitions to related entities (Block, Events, etc.)
 * 4. Type definitions for GraphQL schema integration
 */

import { Model, DataTypes, Optional } from 'sequelize';
import { sequelize } from '../config/database';
import Block from './block';
import { gql, makeExtendSchemaPlugin } from 'postgraphile';
import { TransactionDetailsAttributes } from './transaction-details';

/**
 * Interface defining the core attributes of a Transaction.
 * These attributes represent the fundamental properties of blockchain transactions
 * as stored in the database.
 */
export interface TransactionAttributes {
  id: number;
  blockId: number;
  chainId: number;
  creationtime: string;
  hash: string;
  result: object;
  logs: string;
  num_events: number;
  requestkey: string;
  sender: string;
  txid: string;
  canonical?: boolean;
}

/**
 * Interface for transaction creation, making the 'id' attribute optional
 * since it's auto-generated by the database.
 */
export interface TransactionCreationAttributes extends Optional<TransactionAttributes, 'id'> {}

/**
 * Represents a transaction in the blockchain.
 *
 * A transaction is a record of a state change in the blockchain, containing
 * information about the sender, receiver, amount, and other metadata.
 */
class Transaction
  extends Model<TransactionAttributes, TransactionCreationAttributes>
  implements TransactionAttributes
{
  /** The unique identifier for the transaction record (e.g., 53411). */
  declare id: number;

  /** The ID of the associated block (e.g., 40515). */
  declare blockId: number;

  /** The result of the transaction (e.g., {"data": "Write succeeded", "status": "success"}). */
  declare result: object;

  /** The ID of the blockchain network (e.g., 0). */
  declare chainId: number;

  /** The creation time of the transaction (e.g., "1715747797"). */
  declare creationtime: string;

  /** The hash of the transaction (e.g., "S7v5RXHKgYAWAsnRfYWU_SUh6Jc4g4TU2HOEALj_JSU"). */
  declare hash: string;

  /** The logs generated by the transaction (e.g., "XGZIbkOVNtZkqzi1c2dUP-rrnwG0qALO-EVPXTZhV2I"). */
  declare logs: string;

  /** The number of events generated by the transaction (e.g., 1). */
  declare num_events: number;

  /** The request key of the transaction (e.g., "S7v5RXHKgYAWAsnRfYWU_SUh6Jc4g4TU2HOEALj_JSU"). */
  declare requestkey: string;

  /** The sender of the transaction (e.g., "k:5c54af27ee3d53273bb7b7af9bfba9567e01bff4fbe70da3ee3a57b6d454dbd2"). */
  declare sender: string;

  /** The transaction ID (e.g., "309297606"). */
  declare txid: string;

  /** Indicates whether the transaction is canonical. */
  declare canonical?: boolean;

  /** The associated block. */
  declare block: Block;
}

/**
 * Initialize the Transaction model with its attributes and configuration.
 * This defines the database schema for the Transactions table and sets up indexes
 * for efficient querying of transaction data.
 *
 * TODO: [OPTIMIZATION] Consider evaluating the performance impact of having many indexes
 * and potentially consolidating some of them for better write performance.
 */
Transaction.init(
  {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true,
      comment: 'The unique identifier for the transaction record (e.g., 53411).',
    },
    blockId: {
      type: DataTypes.INTEGER,
      allowNull: true,
      comment: 'The ID of the associated block (e.g., 40515).',
    },
    chainId: {
      type: DataTypes.INTEGER,
      comment: 'The ID of the blockchain network (e.g., 0).',
    },
    creationtime: {
      type: DataTypes.STRING,
      comment: "The creation time of the transaction (e.g., '1715747797').",
    },
    hash: {
      type: DataTypes.STRING,
      comment: "The hash of the transaction (e.g., 'S7v5RXHKgYAWAsnRfYWU_SUh6Jc4g4TU2HOEALj_JSU').",
    },
    result: {
      type: DataTypes.JSONB,
      comment:
        "The result of the transaction (e.g., {'data': 'Write succeeded', 'status': 'success'}).",
    },
    logs: {
      type: DataTypes.STRING,
      comment:
        "The logs generated by the transaction (e.g., 'XGZIbkOVNtZkqzi1c2dUP-rrnwG0qALO-EVPXTZhV2I').",
    },
    num_events: {
      type: DataTypes.INTEGER,
      comment: 'The number of events generated by the transaction (e.g., 1).',
    },
    requestkey: {
      type: DataTypes.STRING,
      comment:
        "The request key of the transaction (e.g., 'S7v5RXHKgYAWAsnRfYWU_SUh6Jc4g4TU2HOEALj_JSU').",
    },
    sender: {
      type: DataTypes.STRING,
      comment:
        "The sender of the transaction (e.g., 'k:5c54af27ee3d53273bb7b7af9bfba9567e01bff4fbe70da3ee3a57b6d454dbd2').",
    },
    txid: {
      type: DataTypes.STRING,
      comment: "The transaction ID (e.g., '309297606').",
    },
    canonical: {
      type: DataTypes.BOOLEAN,
      comment: 'Indicates whether the transaction is canonical.',
    },
  },
  {
    sequelize,
    modelName: 'Transaction',
    indexes: [
      // Regular indexes for common query patterns
      {
        name: 'transactions_requestkey_idx',
        fields: ['requestkey'],
      },
      {
        name: 'transactions_blockId_idx',
        fields: ['blockId'],
      },
      {
        name: 'transactions_sender_idx',
        fields: ['sender'],
      },
      {
        name: 'transactions_chainId_idx',
        fields: ['chainId'],
      },
      {
        name: 'transactions_chainid_blockid_idx',
        fields: ['chainId', 'blockId'],
      },
      {
        name: 'transactions_hash_idx',
        fields: ['hash'],
      },
      {
        name: 'transactions_canonical_idx',
        fields: ['canonical'],
      },
      {
        name: 'transactions_sender_id_idx',
        fields: ['sender', 'id'],
      },
      // Search indexes using trigram similarity for text search performance
      {
        name: 'transactions_trgm_requestkey_idx',
        fields: [sequelize.fn('LOWER', sequelize.col('requestkey'))],
        using: 'gin',
        operator: 'gin_trgm_ops',
      },
      {
        name: 'transactions_trgm_hash_idx',
        fields: [sequelize.fn('LOWER', sequelize.col('hash'))],
        using: 'gin',
        operator: 'gin_trgm_ops',
      },
      {
        name: 'transactions_trgm_txid_idx',
        fields: [sequelize.fn('LOWER', sequelize.col('txid'))],
        using: 'gin',
        operator: 'gin_trgm_ops',
      },
      {
        name: 'transactions_trgm_sender_idx',
        fields: [sequelize.fn('LOWER', sequelize.col('sender'))],
        using: 'gin',
        operator: 'gin_trgm_ops',
      },
    ],
  },
);

/**
 * Define relationship between Transaction and Block models.
 * Each transaction belongs to exactly one block.
 */
Transaction.belongsTo(Block, {
  foreignKey: 'blockId',
});

/**
 * The following interfaces define the GraphQL schema types for representing
 * transaction data in the API. These definitions mirror the structure of the
 * Kadena blockchain's transaction format.
 */

/**
 * Main Transaction interface for GraphQL schema
 */
export interface Transaction_ {
  cmd: TransactionCommand;
  hash: string;
  id: number;
  result: TransactionInfo;
  // sigs: TransactionSignature[];
}

/**
 * Transaction command containing metadata, payload, and signers
 */
export interface TransactionCommand {
  meta: TransactionMeta;
  networkId: string;
  nonce: string;
  payload: TransactionPayload;
  signers: Signer[];
}

/**
 * Transaction metadata including chain ID, creation time, gas settings, etc.
 */
export interface TransactionMeta {
  chainId: BigInt;
  creationTime: Date;
  gasLimit: BigInt;
  gasPrice: number;
  sender: string;
  ttl: BigInt;
}

/**
 * Transaction signature information
 */
export interface TransactionSignature {
  sig: string;
}

/**
 * Information about a transaction in the mempool
 */
export interface TransactionMempoolInfo {
  status: string;
}

/**
 * Union type for transaction info (either mempool info or result)
 */
export type TransactionInfo = TransactionMempoolInfo | TransactionResult;

/**
 * Union type for transaction payload (either continuation or execution)
 */
export type TransactionPayload = ContinuationPayload | ExecutionPayload;

/**
 * Payload for a continuation transaction (multi-step transaction)
 */
export interface ContinuationPayload {
  data: string;
  pactId: string;
  proof: string;
  rollback: boolean;
  step: number;
}

/**
 * Payload for an execution transaction (normal transaction)
 */
export interface ExecutionPayload {
  code: string;
  data: string;
}

/**
 * Result of a transaction execution
 */
export interface TransactionResult {
  badResult: string;
  block: Block_ | null;
  continuation: string;
  eventCount: BigInt;
  events: TransactionResultEventsConnection | null;
  gas: BigInt;
  goodResult: string;
  height: BigInt;
  logs: string;
  transactionId: BigInt;
  transfers: TransactionResultTransfersConnection | null;
}

/**
 * Signer information for a transaction
 */
export interface Signer {
  address: string;
  clist: TransactionCapability[];
  id: number;
  orderIndex: number;
  pubkey: string;
  scheme: string;
}

/**
 * Capability granted to a signer
 */
export interface TransactionCapability {
  args: string;
  name: string;
}

/**
 * Connection type for transaction events (pagination)
 */
export interface TransactionResultEventsConnection {
  edges: TransactionResultEventsConnectionEdge[];
  pageInfo: PageInfo;
  totalCount: number;
}

/**
 * Edge type for transaction events connection
 */
export interface TransactionResultEventsConnectionEdge {
  cursor: string;
  node: Event_;
}

/**
 * Event information
 */
export interface Event_ {
  block: Block_;
  chainId: BigInt;
  height: BigInt;
  id: number;
  incrementedId: number;
  moduleName: string;
  name: string;
  orderIndex: BigInt;
  parameterText: string;
  parameters: string;
  qualifiedName: string;
  requestKey: string;
  transaction: Transaction_;
}

/**
 * Connection type for transaction transfers (pagination)
 */
export interface TransactionResultTransfersConnection {
  edges: TransactionResultTransfersConnectionEdge[];
  pageInfo: PageInfo;
  totalCount: number;
}

/**
 * Edge type for transaction transfers connection
 */
export interface TransactionResultTransfersConnectionEdge {
  cursor: string;
  node: Transfer_;
}

/**
 * Transfer information
 */
export interface Transfer_ {
  amount: number;
  block: Block_;
  blockHash: string;
  chainId: BigInt;
  creationTime: Date;
  crossChainTransfer: Transfer_;
  height: BigInt;
  id: number;
  moduleHash: string;
  moduleName: string;
  orderIndex: BigInt;
  receiverAccount: string;
  requestKey: string;
  senderAccount: string;
  transaction: Transaction_;
}

/**
 * Block information
 */
export interface Block_ {
  chainId: BigInt;
  creationTime: Date;
  difficulty: BigInt;
  epoch: Date;
  events: BlockEventsConnection;
  flags: number;
  hash: string;
  height: BigInt;
  id: number;
  minerAccount: FungibleChainAccount;
  neighbors: BlockNeighbor[];
  nonce: number;
  parent: Block_;
  payloadHash: string;
  powHash: string;
  target: number;
  transactions: BlockTransactionsConnection;
  weight: number;
}

/**
 * Connection type for block events (pagination)
 */
export interface BlockEventsConnection {
  edges: BlockEventsConnectionEdge[];
  pageInfo: PageInfo;
  totalCount: number;
}

/**
 * Edge type for block events connection
 */
export interface BlockEventsConnectionEdge {
  cursor: string;
  node: Event_;
}

/**
 * Information about a fungible chain account
 */
export interface FungibleChainAccount {
  accountName: string;
  balance: number;
  chainId: string;
  fungibleName: string;
  guard: Guard;
  id: number;
  transactions: FungibleChainAccountTransactionsConnection;
  transfers: FungibleChainAccountTransfersConnection;
}

/**
 * Connection type for fungible chain account transactions (pagination)
 */
export interface FungibleChainAccountTransactionsConnection {
  edges: FungibleChainAccountTransactionsConnectionEdge[];
  pageInfo: PageInfo;
  totalCount: number;
}

/**
 * Edge type for fungible chain account transactions connection
 */
export interface FungibleChainAccountTransactionsConnectionEdge {
  cursor: string;
  node: Transaction_;
}

/**
 * Connection type for fungible chain account transfers (pagination)
 */
export interface FungibleChainAccountTransfersConnection {
  edges: FungibleChainAccountTransfersConnectionEdge[];
  pageInfo: PageInfo;
  totalCount: number;
}

/**
 * Edge type for fungible chain account transfers connection
 */
export interface FungibleChainAccountTransfersConnectionEdge {
  cursor: string;
  node: Transfer_;
}

/**
 * Guard information (security mechanism)
 */
export interface Guard {
  keys: string[];
  predicate: string;
}

/**
 * Information about a block neighbor
 */
export interface BlockNeighbor {
  chainId: string;
  hash: string;
}

/**
 * Connection type for block transactions (pagination)
 */
export interface BlockTransactionsConnection {
  edges: BlockTransactionsConnectionEdge[];
  pageInfo: PageInfo;
  totalCount: number;
}

/**
 * Edge type for block transactions connection
 */
export interface BlockTransactionsConnectionEdge {
  cursor: string;
  node: Transaction_;
}

/**
 * Pagination information
 */
export interface PageInfo {
  endCursor: string;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor: string;
}

/**
 * Kadena Extension Plugin for GraphQL
 *
 * This plugin extends the GraphQL schema with custom types and queries for Kadena blockchain transactions.
 * It provides the detailed transaction schema that mirrors the Kadena blockchain's data structure,
 * allowing API consumers to query transaction data in a structured and type-safe way.
 *
 * The plugin defines:
 * 1. A transaction_ query to fetch a transaction by its request key
 * 2. Complex nested types for all transaction-related entities
 * 3. Type resolvers for union types
 * 4. Field resolvers for computed properties
 *
 * This extension follows the Kadena blockchain's data model more closely than the simplified
 * model used in the database, providing a richer API surface for developers.
 */
export const kadenaExtensionPlugin = makeExtendSchemaPlugin(build => {
  return {
    typeDefs: gql`
      extend type Query {
        transaction_(requestkey: String!): Transaction_
      }

      type Transaction_ {
        cmd: TransactionCommand!
        hash: String!
        id: ID!
        result: TransactionInfo!
      }

      type TransactionCommand {
        meta: TransactionMeta!
        networkId: String!
        nonce: String!
        payload: TransactionPayload!
        signers: [Signer!]!
      }

      type TransactionMeta {
        chainId: BigInt!
        creationTime: Datetime!
        gasLimit: BigInt!
        gasPrice: Float!
        sender: String!
        ttl: BigInt!
      }

      type TransactionSignature {
        sig: String!
      }

      type TransactionMempoolInfo {
        status: String
      }

      union TransactionInfo = TransactionMempoolInfo | TransactionResult
      union TransactionPayload = ContinuationPayload | ExecutionPayload

      type ContinuationPayload {
        data: String!
        pactId: String
        proof: String
        rollback: Boolean
        step: Int
      }

      type ExecutionPayload {
        code: String
        data: String!
      }

      type TransactionResult {
        badResult: String
        block: Block_!
        continuation: String
        eventCount: BigInt
        events(
          after: String
          before: String
          first: Int
          last: Int
        ): TransactionResultEventsConnection!
        gas: BigInt!
        goodResult: String
        height: BigInt!
        logs: String
        transactionId: BigInt
        transfers(
          after: String
          before: String
          first: Int
          last: Int
        ): TransactionResultTransfersConnection!
      }

      type Signer {
        address: String
        clist: [TransactionCapability!]!
        id: ID!
        orderIndex: Int
        pubkey: String!
        scheme: String
      }

      type TransactionCapability {
        args: String!
        name: String!
      }

      type TransactionResultEventsConnection {
        edges: [TransactionResultEventsConnectionEdge]!
        pageInfo: PageInfo!
        totalCount: Int!
      }

      type TransactionResultEventsConnectionEdge {
        cursor: String!
        node: Event_!
      }

      type Event_ {
        block: Block_!
        chainId: BigInt!
        height: BigInt!
        id: ID!
        incrementedId: Int!
        moduleName: String!
        name: String!
        orderIndex: BigInt!
        parameterText: String!
        parameters: String
        qualifiedName: String!
        requestKey: String!
        transaction: Transaction_
      }

      type TransactionResultTransfersConnection {
        edges: [TransactionResultTransfersConnectionEdge]!
        pageInfo: PageInfo!
        totalCount: Int!
      }

      type TransactionResultTransfersConnectionEdge {
        cursor: String!
        node: Transfer_!
      }

      type Transfer_ {
        amount: BigFloat!
        block: Block_!
        blockHash: String!
        chainId: BigInt!
        creationTime: Datetime!
        crossChainTransfer: Transfer_
        height: BigInt!
        id: ID!
        moduleHash: String!
        moduleName: String!
        orderIndex: BigInt!
        receiverAccount: String!
        requestKey: String!
        senderAccount: String!
        transaction: Transaction_
      }

      type Block_ {
        chainId: BigInt!
        creationTime: Datetime!
        difficulty: BigInt!
        epoch: Datetime!
        events(after: String, before: String, first: Int, last: Int): BlockEventsConnection!
        flags: BigFloat!
        hash: String!
        height: BigInt!
        id: ID!
        minerAccount: FungibleChainAccount!
        neighbors: [BlockNeighbor!]!
        nonce: BigFloat!
        parent: Block_
        payloadHash: String!
        powHash: String!
        target: BigFloat!
        transactions(
          after: String
          before: String
          first: Int
          last: Int
        ): BlockTransactionsConnection!
        weight: BigFloat!
      }

      type BlockEventsConnection {
        edges: [BlockEventsConnectionEdge!]!
        pageInfo: PageInfo!
        totalCount: Int!
      }

      type BlockEventsConnectionEdge {
        cursor: String!
        node: Event_!
      }

      type FungibleChainAccount {
        accountName: String!
        balance: Float!
        chainId: String!
        fungibleName: String!
        guard: Guard!
        id: ID!
        transactions(
          after: String
          before: String
          first: Int
          last: Int
        ): FungibleChainAccountTransactionsConnection!
        transfers(
          after: String
          before: String
          first: Int
          last: Int
        ): FungibleChainAccountTransfersConnection!
      }

      type FungibleChainAccountTransactionsConnection {
        edges: [FungibleChainAccountTransactionsConnectionEdge!]!
        pageInfo: PageInfo!
        totalCount: Int!
      }

      type FungibleChainAccountTransactionsConnectionEdge {
        cursor: String!
        node: Transaction_!
      }

      type FungibleChainAccountTransfersConnection {
        edges: [FungibleChainAccountTransfersConnectionEdge!]!
        pageInfo: PageInfo!
        totalCount: Int!
      }

      type FungibleChainAccountTransfersConnectionEdge {
        cursor: String!
        node: Transfer_!
      }

      type Guard {
        keys: [String!]!
        predicate: String!
      }

      type BlockNeighbor {
        chainId: String!
        hash: String!
      }

      type BlockTransactionsConnection {
        edges: [BlockTransactionsConnectionEdge!]!
        pageInfo: PageInfo!
        totalCount: Int!
      }

      type BlockTransactionsConnectionEdge {
        cursor: String!
        node: Transaction_!
      }
    `,
    resolvers: {
      /**
       * Type resolver for the TransactionPayload union type.
       * Determines whether a payload is an execution or continuation based on the presence of a code field.
       */
      TransactionPayload: {
        __resolveType(obj) {
          if (obj.code) {
            return 'ExecutionPayload';
          }
          return 'ContinuationPayload';
        },
      },
      Query: {
        /**
         * Resolver for the transaction_ query.
         * Fetches a transaction by its request key and joins with transaction details.
         * Transforms the database representation into the GraphQL schema representation.
         *
         * @param _query - The parent object (not used)
         * @param args - The query arguments, including the requestkey
         * @param context - The context object containing database connections
         * @param resolveInfo - GraphQL resolve info (not used)
         * @returns The transaction data or null if not found
         *
         * TODO: [OPTIMIZATION] Consider adding caching for frequently accessed transactions
         */
        transaction_: async (_query, args, context, resolveInfo) => {
          const { requestkey } = args;
          const { rootPgPool } = context;

          // Fetch transaction and its details using a JOIN
          const { rows: transactions } = await rootPgPool.query(
            `SELECT t.*, td.* FROM public."Transactions" t LEFT JOIN public."TransactionDetails" td ON t.id = td."transactionId" WHERE t.requestkey = $1`,
            [requestkey],
          );

          var results: Array<Transaction_> = [];

          // Transform each transaction into the GraphQL schema format
          transactions.forEach(
            (transaction: TransactionAttributes & TransactionDetailsAttributes) => {
              results.push({
                cmd: {
                  meta: {
                    chainId: BigInt(transaction.chainId),
                    creationTime: new Date(parseInt(transaction.creationtime) * 1000),
                    gasLimit: BigInt(transaction.gaslimit),
                    gasPrice: parseFloat(transaction.gasprice),
                    sender: transaction.sender,
                    ttl: BigInt(transaction.ttl),
                  },
                  networkId: transaction.chainId ? transaction.chainId.toString() : '',
                  nonce: transaction.nonce,
                  payload:
                    transaction.continuation.toString() == ''
                      ? ({
                          code: transaction.code ? transaction.code.toString() : '',
                          data: JSON.stringify(transaction.data),
                        } as ExecutionPayload)
                      : ({
                          data: JSON.stringify(transaction.data),
                          pactId: transaction.pactid,
                          proof: transaction.proof,
                          rollback: transaction.rollback,
                          step: transaction.step,
                        } as ContinuationPayload),
                  signers: [],
                },
                hash: transaction.hash,
                id: transaction.id,
                result: {
                  badResult: transaction.rollback ? transaction.result.toString() : '',
                  block: null,
                  continuation: transaction.continuation ? transaction.continuation.toString() : '',
                  eventCount: BigInt(transaction.num_events),
                  events: null,
                  gas: BigInt(transaction.gas),
                  goodResult: transaction.rollback ? '' : transaction.result.toString(),
                  height: BigInt(0),
                  logs: transaction.logs ? transaction.logs.toString() : '',
                  transactionId: BigInt(transaction.id),
                  transfers: null,
                },
              });
            },
          );

          // Return the first transaction or null
          if (results.length > 0) {
            return results[0];
          } else {
            return null;
          }
        },
      },
    },
  };
});

/**
 * Transaction By Request Key Query Plugin
 *
 * This plugin extends the GraphQL schema with a custom query to fetch a transaction
 * by its request key, along with its associated events and transfers.
 *
 * Unlike the kadenaExtensionPlugin which follows the Kadena blockchain's data model,
 * this plugin provides a more simplified and denormalized view of transaction data
 * that's optimized for common application use cases.
 *
 * Features:
 * 1. Returns transaction data in a simplified format
 * 2. Includes related events and transfers
 * 3. Supports limiting the number of events and transfers returned
 * 4. Joins contract information for transfers
 */
export const transactionByRequestKeyQueryPlugin = makeExtendSchemaPlugin(build => {
  return {
    typeDefs: gql`
      extend type Query {
        transactionByRequestKey(
          requestkey: String!
          eventLimit: Int
          transferLimit: Int
        ): TransactionData
      }

      type TransactionData {
        transaction: Transaction
        events: [Event]
        transfers: [TransferData]
      }

      type TransferData {
        transfer: Transfer
        contract: Contract
      }
    `,
    resolvers: {
      Query: {
        /**
         * Resolver for the transactionByRequestKey query.
         * Fetches a transaction by its request key, along with related events and transfers.
         *
         * @param _query - The parent object (not used)
         * @param args - The query arguments, including requestkey, eventLimit, and transferLimit
         * @param context - The context object containing database connections
         * @param resolveInfo - GraphQL resolve info (not used)
         * @returns The transaction data with related events and transfers, or null if not found
         *
         * TODO: [OPTIMIZATION] Consider using a single query with JOINs instead of multiple queries
         * to reduce database round-trips.
         */
        transactionByRequestKey: async (_query, args, context, resolveInfo) => {
          const { requestkey, eventLimit, transferLimit } = args;
          const { rootPgPool } = context;

          // Fetch the transaction by request key
          const { rows: transactions } = await rootPgPool.query(
            `SELECT * FROM public."Transactions" WHERE requestkey = $1`,
            [requestkey],
          );

          if (transactions.length === 0) {
            return null;
          }

          const transaction = transactions[0];

          // Fetch events for the transaction with optional limit
          const eventLimitClause = eventLimit ? `LIMIT $2` : '';
          const eventQueryParams = eventLimit ? [transaction.id, eventLimit] : [transaction.id];
          const { rows: events } = await rootPgPool.query(
            `SELECT * FROM public."Events" WHERE "transactionId" = $1 ${eventLimitClause}`,
            eventQueryParams,
          );

          // Fetch transfers for the transaction with optional limit
          const transferLimitClause = transferLimit ? `LIMIT $2` : '';
          const transferQueryParams = transferLimit
            ? [transaction.id, transferLimit]
            : [transaction.id];
          const { rows: transfers } = await rootPgPool.query(
            `SELECT * FROM public."Transfers" WHERE "transactionId" = $1 ${transferLimitClause}`,
            transferQueryParams,
          );

          // Fetch contract information for each transfer
          const transferDataPromises = transfers.map(async (transfer: any) => {
            let contract = null;
            transfer.toAcct = transfer.to_acct;
            transfer.fromAcct = transfer.from_acct;
            if (transfer.contractId) {
              const { rows: contracts } = await rootPgPool.query(
                `SELECT * FROM public."Contracts" WHERE id = $1`,
                [transfer.contractId],
              );
              contract = contracts.length > 0 ? contracts[0] : null;
            }

            return {
              transfer,
              contract,
            };
          });

          const transferData = await Promise.all(transferDataPromises);

          transaction.numEvents = events.length;

          // Return the aggregated transaction data
          return {
            transaction,
            events,
            transfers: transferData,
          };
        },
      },
    },
  };
});

/**
 * Transactions By Block ID Query Plugin
 *
 * This plugin extends the GraphQL schema with a query to fetch transactions by block ID,
 * with support for cursor-based pagination. This allows API consumers to efficiently
 * browse through large numbers of transactions in a block.
 *
 * Features:
 * 1. Fetches transactions for a specific block
 * 2. Implements cursor-based pagination for efficient traversal
 * 3. Returns pageInfo for implementing "load more" functionality
 * 4. Orders transactions by ID for consistent pagination
 */
export const transactionsByBlockIdQueryPlugin = makeExtendSchemaPlugin(build => {
  return {
    typeDefs: gql`
      extend type Query {
        transactionsByBlockId(blockId: Int!, first: Int, after: String): TransactionConnection
      }

      type TransactionConnection {
        edges: [TransactionEdge]
        pageInfo: PageInfo
      }

      type TransactionEdge {
        node: Transaction
        cursor: String
      }
    `,
    resolvers: {
      Query: {
        /**
         * Resolver for the transactionsByBlockId query.
         * Fetches transactions for a specific block with cursor-based pagination.
         *
         * @param _query - The parent object (not used)
         * @param args - The query arguments, including blockId, first, and after cursor
         * @param context - The context object containing database connections
         * @param resolveInfo - GraphQL resolve info (not used)
         * @returns A connection object with transaction edges and page info
         *
         * TODO: [OPTIMIZATION] Consider implementing more efficient cursor encoding/decoding
         * for better performance with large result sets.
         */
        transactionsByBlockId: async (_query, args, context, resolveInfo) => {
          const { blockId, first, after } = args;
          const { rootPgPool } = context;

          // Build the query with cursor-based pagination
          let cursorCondition = '';
          const limit = first || 10; // Default to 10 items if not specified
          const values = [blockId, limit + 1]; // Request one more to check for more pages

          if (after) {
            cursorCondition = 'AND id > $3';
            values.push(Buffer.from(after, 'base64').toString('ascii'));
          }

          const query = `
            SELECT * FROM public."Transactions"
            WHERE "blockId" = $1
            ${cursorCondition}
            ORDER BY id
            LIMIT $2
          `;

          const { rows } = await rootPgPool.query(query, values);

          // Check if there are more pages
          const hasNextPage = rows.length > limit;
          if (hasNextPage) {
            rows.pop(); // Remove the extra item
          }

          // Create edges with cursor
          const edges = rows.map((row: any) => ({
            node: row,
            cursor: Buffer.from(row.id.toString(), 'ascii').toString('base64'),
          }));

          const endCursor = edges.length > 0 ? edges[edges.length - 1].cursor : null;

          // Return the connection object
          return {
            edges,
            pageInfo: {
              endCursor,
              hasNextPage,
            },
          };
        },
      },
    },
  };
});

export default Transaction;
