export const transactionsFixture016 = {
  data: {
    transactions: {
      pageInfo: {
        endCursor: 'MDozMDIxMTk3NQ==',
        hasNextPage: false,
        hasPreviousPage: true,
        startCursor: 'MDo0NTA3OTIyMg==',
      },
      edges: [
        {
          cursor: 'MDo0NTA3OTIyMg==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJhVkZGcUY4UGJHdS1NWmtVaGIxT2s0WGlqZ3hXVVl4QnhpZ0JRZ1ptREZJIiwiNDhUMExqQW5TRnBGV3h2dmFQVi1fNkUtQ2pEQVBoV1lVRldidnlmMmxGcyJd',
            hash: '48T0LjAnSFpFWxvvaPV-_6E-CjDAPhWYUFWbvyf2lFs',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface fungible-v1\\n\\n  \\" Standard for fungible coins and tokens as specified in KIP-0002. \\"\\n\\n   ; ----------------------------------------------------------------------\\n   ; Schema\\n\\n   (defschema account-details\\n    @doc \\"Schema for results of \'account\' operation.\\"\\n    @model [ (invariant (!= \\"\\" sender)) ]\\n\\n    account:string\\n    balance:decimal\\n    guard:guard)\\n\\n\\n   ; ----------------------------------------------------------------------\\n   ; Caps\\n\\n   (defcap TRANSFER:bool\\n     ( sender:string\\n       receiver:string\\n       amount:decimal\\n     )\\n     @doc \\" Managed capability sealing AMOUNT for transfer from SENDER to \\\\\\n          \\\\ RECEIVER. Permits any number of transfers up to AMOUNT.\\"\\n     @managed amount TRANSFER-mgr\\n     )\\n\\n   (defun TRANSFER-mgr:decimal\\n     ( managed:decimal\\n       requested:decimal\\n     )\\n     @doc \\" Manages TRANSFER AMOUNT linearly, \\\\\\n          \\\\ such that a request for 1.0 amount on a 3.0 \\\\\\n          \\\\ managed quantity emits updated amount 2.0.\\"\\n     )\\n\\n   ; ----------------------------------------------------------------------\\n   ; Functionality\\n\\n   (defun transfer-create:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       amount:decimal\\n     )\\n     @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n          \\\\ Fails if SENDER does not exist. If RECEIVER exists, guard \\\\\\n          \\\\ must match existing value. If RECEIVER does not exist, \\\\\\n          \\\\ RECEIVER account is created using RECEIVER-GUARD. \\\\\\n          \\\\ Subject to management by TRANSFER capability.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n            ]\\n     )\\n\\n   (defpact transfer-crosschain:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       target-chain:string\\n       amount:decimal\\n     )\\n     @doc \\" 2-step pact to transfer AMOUNT from SENDER on current chain \\\\\\n          \\\\ to RECEIVER on TARGET-CHAIN via SPV proof. \\\\\\n          \\\\ TARGET-CHAIN must be different than current chain id. \\\\\\n          \\\\ First step debits AMOUNT coins in SENDER account and yields \\\\\\n          \\\\ RECEIVER, RECEIVER_GUARD and AMOUNT to TARGET-CHAIN. \\\\\\n          \\\\ Second step continuation is sent into TARGET-CHAIN with proof \\\\\\n          \\\\ obtained from the spv \'output\' endpoint of Chainweb. \\\\\\n          \\\\ Proof is validated and RECEIVER is credited with AMOUNT \\\\\\n          \\\\ creating account with RECEIVER_GUARD as necessary.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n              (property (!= target-chain \\"\\"))\\n            ]\\n     )\\n\\n   (defun get-balance:decimal\\n     ( account:string )\\n     \\" Get balance for ACCOUNT. Fails if account does not exist.\\"\\n     )\\n\\n   (defun details:object{account-details}\\n     ( account: string )\\n     \\" Get an object with details of ACCOUNT. \\\\\\n     \\\\ Fails if account does not exist.\\"\\n     )\\n\\n   (defun precision:integer\\n     ()\\n     \\"Return the maximum allowed decimal precision.\\"\\n     )\\n\\n   (defun enforce-unit:bool\\n     ( amount:decimal )\\n     \\" Enforce minimum precision allowed for transactions.\\"\\n     )\\n\\n   (defun create-account:string\\n     ( account:string\\n       guard:guard\\n     )\\n     \\" Create ACCOUNT with 0.0 balance, with GUARD controlling access.\\"\\n     )\\n\\n   (defun rotate:string\\n     ( account:string\\n       new-guard:guard\\n     )\\n     \\" Rotate guard for ACCOUNT. Transaction is validated against \\\\\\n     \\\\ existing guard before installing new guard. \\"\\n     )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface fungible-v1"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozODAxMDY5Nw==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyIwOXFrOXVsd3RxODU0b2dKd2xEWktON05DX1EzbHFpeTFqZEQwX1l2V01JIiwiMDRzUF9ScVkxTUhya2pZa3VHUFV0VHB0QXlEMXhjTUh2N0lHTU5FRDJMWSJd',
            hash: '04sP_RqY1MHrkjYkuGPUtTptAyD1xcMHv7IGMNED2LY',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(coin.create-allocation-account \\"PS_C8_1317\\" (time \\"2024-12-01T00:00:00Z\\") \\"PS_C8\\" 1200000.0)\\n(coin.create-allocation-account \\"PS_C8_1307\\" (time \\"2024-11-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1297\\" (time \\"2024-10-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1287\\" (time \\"2024-09-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1277\\" (time \\"2024-08-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1267\\" (time \\"2024-07-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1257\\" (time \\"2024-06-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1247\\" (time \\"2024-05-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1237\\" (time \\"2024-04-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1227\\" (time \\"2024-03-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1217\\" (time \\"2024-02-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1207\\" (time \\"2024-01-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1197\\" (time \\"2023-12-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1187\\" (time \\"2023-11-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1177\\" (time \\"2023-10-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1167\\" (time \\"2023-09-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1157\\" (time \\"2023-08-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1147\\" (time \\"2023-07-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1137\\" (time \\"2023-06-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1127\\" (time \\"2023-05-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1117\\" (time \\"2023-04-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1107\\" (time \\"2023-03-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1097\\" (time \\"2023-02-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1087\\" (time \\"2023-01-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1077\\" (time \\"2022-12-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1067\\" (time \\"2022-11-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1056\\" (time \\"2022-10-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1046\\" (time \\"2022-09-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1036\\" (time \\"2022-08-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1025\\" (time \\"2022-07-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1015\\" (time \\"2022-06-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_1005\\" (time \\"2022-05-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_994\\" (time \\"2022-04-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_984\\" (time \\"2022-03-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_974\\" (time \\"2022-02-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_963\\" (time \\"2022-01-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_952\\" (time \\"2021-12-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_941\\" (time \\"2021-11-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_929\\" (time \\"2021-10-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_918\\" (time \\"2021-09-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_907\\" (time \\"2021-08-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_895\\" (time \\"2021-07-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_884\\" (time \\"2021-06-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_873\\" (time \\"2021-05-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_860\\" (time \\"2021-04-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_848\\" (time \\"2021-03-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_836\\" (time \\"2021-02-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C8_823\\" (time \\"2021-01-01T00:00:00Z\\") \\"PS_C8\\" 400000.0)"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Write succeeded"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozODAxMDY5Ng==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyIwOXFrOXVsd3RxODU0b2dKd2xEWktON05DX1EzbHFpeTFqZEQwX1l2V01JIiwiNVFSSjlaMDZSWDM1MDJSal9FN1ZGMG4zRHBWSGdheElMNHV0S2FPZHN0QSJd',
            hash: '5QRJ9Z06RX3502Rj_E7VF0n3DpVHgaxIL4utKaOdstA',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(define-keyset \\"SA <1>\\" (read-keyset \\"SA <1>\\"))\\n(define-keyset \\"SA <2>\\" (read-keyset \\"SA <2>\\"))\\n(define-keyset \\"SA <3>\\" (read-keyset \\"SA <3>\\"))\\n(define-keyset \\"SA <4>\\" (read-keyset \\"SA <4>\\"))\\n(define-keyset \\"SA <5>\\" (read-keyset \\"SA <5>\\"))\\n(define-keyset \\"SA <6>\\" (read-keyset \\"SA <6>\\"))\\n(define-keyset \\"SA <7>\\" (read-keyset \\"SA <7>\\"))\\n(define-keyset \\"SA <8>\\" (read-keyset \\"SA <8>\\"))\\n(define-keyset \\"SA <9>\\" (read-keyset \\"SA <9>\\"))\\n(define-keyset \\"SA <10>\\" (read-keyset \\"SA <10>\\"))\\n(define-keyset \\"SA <11>\\" (read-keyset \\"SA <11>\\"))\\n(define-keyset \\"SA <12>\\" (read-keyset \\"SA <12>\\"))\\n(define-keyset \\"SA <13>\\" (read-keyset \\"SA <13>\\"))\\n(define-keyset \\"SA <14>\\" (read-keyset \\"SA <14>\\"))\\n(define-keyset \\"SA <15>\\" (read-keyset \\"SA <15>\\"))\\n(define-keyset \\"SA <16>\\" (read-keyset \\"SA <16>\\"))\\n(define-keyset \\"SA <17>\\" (read-keyset \\"SA <17>\\"))\\n(define-keyset \\"SA <18>\\" (read-keyset \\"SA <18>\\"))\\n(define-keyset \\"SA <19>\\" (read-keyset \\"SA <19>\\"))\\n(define-keyset \\"SA <20>\\" (read-keyset \\"SA <20>\\"))\\n(define-keyset \\"SB <1>\\" (read-keyset \\"SB <1>\\"))\\n(define-keyset \\"SB <2>\\" (read-keyset \\"SB <2>\\"))\\n(define-keyset \\"SB <3>\\" (read-keyset \\"SB <3>\\"))\\n(define-keyset \\"SB <4>\\" (read-keyset \\"SB <4>\\"))\\n(define-keyset \\"SB <5>\\" (read-keyset \\"SB <5>\\"))\\n(define-keyset \\"SB <6>\\" (read-keyset \\"SB <6>\\"))\\n(define-keyset \\"SB <7>\\" (read-keyset \\"SB <7>\\"))\\n(define-keyset \\"SB <8>\\" (read-keyset \\"SB <8>\\"))\\n(define-keyset \\"SB <9>\\" (read-keyset \\"SB <9>\\"))\\n(define-keyset \\"SB <10>\\" (read-keyset \\"SB <10>\\"))\\n(define-keyset \\"SB <11>\\" (read-keyset \\"SB <11>\\"))\\n(define-keyset \\"SB <12>\\" (read-keyset \\"SB <12>\\"))\\n(define-keyset \\"SB <13>\\" (read-keyset \\"SB <13>\\"))\\n(define-keyset \\"SB <14>\\" (read-keyset \\"SB <14>\\"))\\n(define-keyset \\"SB <15>\\" (read-keyset \\"SB <15>\\"))\\n(define-keyset \\"SB <16>\\" (read-keyset \\"SB <16>\\"))\\n(define-keyset \\"SB <17>\\" (read-keyset \\"SB <17>\\"))\\n(define-keyset \\"SB <18>\\" (read-keyset \\"SB <18>\\"))\\n(define-keyset \\"SB <19>\\" (read-keyset \\"SB <19>\\"))\\n(define-keyset \\"SB <20>\\" (read-keyset \\"SB <20>\\"))\\n(define-keyset \\"SB <21>\\" (read-keyset \\"SB <21>\\"))\\n(define-keyset \\"SB <22>\\" (read-keyset \\"SB <22>\\"))\\n(define-keyset \\"SB <23>\\" (read-keyset \\"SB <23>\\"))\\n(define-keyset \\"SB <24>\\" (read-keyset \\"SB <24>\\"))\\n(define-keyset \\"SB <25>\\" (read-keyset \\"SB <25>\\"))\\n(define-keyset \\"SB <26>\\" (read-keyset \\"SB <26>\\"))\\n(define-keyset \\"SB <27>\\" (read-keyset \\"SB <27>\\"))\\n(define-keyset \\"SB <28>\\" (read-keyset \\"SB <28>\\"))\\n(define-keyset \\"SB <29>\\" (read-keyset \\"SB <29>\\"))\\n(define-keyset \\"SB <30>\\" (read-keyset \\"SB <30>\\"))\\n(define-keyset \\"SB <31>\\" (read-keyset \\"SB <31>\\"))\\n(define-keyset \\"SB <32>\\" (read-keyset \\"SB <32>\\"))\\n(define-keyset \\"SB <33>\\" (read-keyset \\"SB <33>\\"))\\n(define-keyset \\"SB <34>\\" (read-keyset \\"SB <34>\\"))\\n(define-keyset \\"SB <35>\\" (read-keyset \\"SB <35>\\"))\\n(define-keyset \\"SB <36>\\" (read-keyset \\"SB <36>\\"))\\n(define-keyset \\"SB <37>\\" (read-keyset \\"SB <37>\\"))\\n(define-keyset \\"SB <38>\\" (read-keyset \\"SB <38>\\"))\\n(define-keyset \\"SB <39>\\" (read-keyset \\"SB <39>\\"))\\n(define-keyset \\"SB <40>\\" (read-keyset \\"SB <40>\\"))\\n(define-keyset \\"SB <41>\\" (read-keyset \\"SB <41>\\"))\\n(define-keyset \\"SB <42>\\" (read-keyset \\"SB <42>\\"))\\n(define-keyset \\"SB <43>\\" (read-keyset \\"SB <43>\\"))\\n(define-keyset \\"SB <44>\\" (read-keyset \\"SB <44>\\"))\\n(define-keyset \\"SB <45>\\" (read-keyset \\"SB <45>\\"))\\n(define-keyset \\"SB <46>\\" (read-keyset \\"SB <46>\\"))\\n(define-keyset \\"PS_C0\\" (read-keyset \\"PS_C0\\"))\\n(define-keyset \\"PS_C1\\" (read-keyset \\"PS_C1\\"))\\n(define-keyset \\"PS_C2\\" (read-keyset \\"PS_C2\\"))\\n(define-keyset \\"PS_C3\\" (read-keyset \\"PS_C3\\"))\\n(define-keyset \\"PS_C4\\" (read-keyset \\"PS_C4\\"))\\n(define-keyset \\"PS_C5\\" (read-keyset \\"PS_C5\\"))\\n(define-keyset \\"PS_C6\\" (read-keyset \\"PS_C6\\"))\\n(define-keyset \\"PS_C7\\" (read-keyset \\"PS_C7\\"))\\n(define-keyset \\"PS_C8\\" (read-keyset \\"PS_C8\\"))\\n(define-keyset \\"PS_C9\\" (read-keyset \\"PS_C9\\"))\\n(define-keyset \\"EB_C9\\" (read-keyset \\"EB_C9\\"))\\n(define-keyset \\"Coinlist Non-US\\" (read-keyset \\"Coinlist Non-US\\"))\\n(define-keyset \\"Coinlist Global\\" (read-keyset \\"Coinlist Global\\"))\\n(define-keyset \\"FTS_C1\\" (read-keyset \\"FTS_C1\\"))\\n(define-keyset \\"CS1_C2\\" (read-keyset \\"CS1_C2\\"))\\n(define-keyset \\"CS2_C0\\" (read-keyset \\"CS2_C0\\"))\\n(define-keyset \\"ST_C1\\" (read-keyset \\"ST_C1\\"))"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Keyset defined"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozODAxMDY5NQ==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyIwOXFrOXVsd3RxODU0b2dKd2xEWktON05DX1EzbHFpeTFqZEQwX1l2V01JIiwiRC1tY0VzMWJycE1OTloxTkx5a2haNEo5cFdFcHJYQmh1V2hDbWZFYUR0VSJd',
            hash: 'D-mcEs1brpMNNZ1NLykhZ4J9pWEprXBhuWhCmfEaDtU',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"\\n(define-keyset \'ns-admin-keyset (read-keyset \'ns-admin-keyset))\\n(define-keyset \'ns-operate-keyset (read-keyset \'ns-genesis-keyset))\\n\\n(module ns GOVERNANCE\\n  \\"Administers definition of new namespaces in Chainweb.\\"\\n\\n  (defschema reg-entry\\n    admin-guard:guard\\n    active:bool)\\n\\n  (deftable registry:{reg-entry})\\n\\n  (defcap GOVERNANCE ()\\n    (enforce-keyset \'ns-admin-keyset))\\n\\n  (defcap OPERATE ()\\n    (enforce-keyset \'ns-operate-keyset))\\n\\n  (defconst GUARD_SUCCESS (create-user-guard (success)))\\n  (defconst GUARD_FAILURE (create-user-guard (failure)))\\n\\n  (defun success ()\\n    true)\\n  (defun failure ()\\n    (enforce false \\"Disabled\\"))\\n\\n  (defun validate-name (name)\\n    (enforce (!= \\"\\" name) \\"Empty name not allowed\\")\\n    (enforce (< (length name) 64) \\"Name must be less than 64 characters long\\")\\n    (enforce (is-charset CHARSET_LATIN1 name)\\n             \\"Name must be in latin1 charset\\"))\\n\\n  (defun validate:bool\\n      ( ns-name:string\\n        ns-admin:guard\\n        )\\n    \\" Manages namespace install for Chainweb. Requires active row in registry \\\\\\n    \\\\ for NS-NAME with guard matching NS-ADMIN.\\"\\n\\n    (validate-name ns-name)\\n\\n    (with-default-read registry ns-name\\n      { \'admin-guard : ns-admin\\n      , \'active : false }\\n      { \'admin-guard := ag\\n      , \'active := is-active }\\n\\n        (enforce is-active \\"Inactive or unregistered namespace\\")\\n        (enforce (= ns-admin ag) \\"Admin guard must match guard in registry\\")\\n\\n        true))\\n\\n  (defun write-registry:string\\n      ( ns-name:string\\n        guard:guard\\n        active:bool\\n        )\\n    \\" Write entry with GUARD and ACTIVE into registry for NAME. \\\\\\n    \\\\ Guarded by operate keyset. \\"\\n\\n    (with-capability (OPERATE)\\n\\n      (validate-name ns-name)\\n\\n      (write registry ns-name\\n        { \'admin-guard: guard\\n        , \'active: active })\\n\\n      \\"Register entry written\\"))\\n\\n  (defun query:object{reg-entry}\\n      ( ns-name:string )\\n    (read registry ns-name))\\n\\n  )\\n\\n(create-table registry)\\n\\n(write-registry \\"kadena\\"\\n  (keyset-ref-guard \'ns-operate-keyset) true)\\n(write-registry \\"user\\" GUARD_FAILURE true)\\n(write-registry \\"free\\" GUARD_FAILURE true)\\n\\n(define-namespace \\"kadena\\"\\n  (keyset-ref-guard \'ns-operate-keyset)\\n  (keyset-ref-guard \'ns-operate-keyset))\\n\\n(define-namespace \\"user\\" GUARD_SUCCESS GUARD_FAILURE)\\n(define-namespace \\"free\\" GUARD_SUCCESS GUARD_FAILURE)\\n;;rotate to real operate keyset\\n(define-keyset \'ns-operate-keyset (read-keyset \'ns-operate-keyset))\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Keyset defined"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozODAxMDY5NA==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyIwOXFrOXVsd3RxODU0b2dKd2xEWktON05DX1EzbHFpeTFqZEQwX1l2V01JIiwiU0IzVzVFTGl6azl4elNWWk9MX3dsem5VNjh5aUhPQzlwWUhreHBVXzBnbyJd',
            hash: 'SB3W5ELizk9xzSVZOL_wlznU68yiHOC9pYHkxpU_0go',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface gas-payer-v1\\n\\n  (defcap GAS_PAYER:bool\\n    ( user:string\\n      limit:integer\\n      price:decimal\\n    )\\n    @doc\\n    \\" Provide a capability indicating that declaring module supports \\\\\\n    \\\\ gas payment for USER for gas LIMIT and PRICE. Functionality \\\\\\n    \\\\ should require capability (coin.FUND_TX), and should validate \\\\\\n    \\\\ the spend of (limit * price), possibly updating some database \\\\\\n    \\\\ entry. \\\\\\n    \\\\ Should compose capability required for \'create-gas-payer-guard\'.\\"\\n    @model\\n    [ (property (user != \\"\\"))\\n      (property (limit > 0))\\n      (property (price > 0.0))\\n    ]\\n  )\\n\\n  (defun create-gas-payer-guard:guard ()\\n    @doc\\n    \\" Provide a guard suitable for controlling a coin account that can \\\\\\n    \\\\ pay gas via GAS_PAYER mechanics. Generally this is accomplished \\\\\\n    \\\\ by having GAS_PAYER compose an unparameterized, unmanaged capability \\\\\\n    \\\\ that is required in this guard. Thus, if coin contract is able to \\\\\\n    \\\\ successfully acquire GAS_PAYER, the composed \'anonymous\' cap required \\\\\\n    \\\\ here will be in scope, and gas buy will succeed.\\"\\n  )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface gas-payer-v1"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozODAxMDY5Mw==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyIwOXFrOXVsd3RxODU0b2dKd2xEWktON05DX1EzbHFpeTFqZEQwX1l2V01JIiwiWEdQRVFEazVQSXZRa3BxMEdHa2dOVG1vLW1qa2k2M1pQZ0VSX2tvdnhxNCJd',
            hash: 'XGPEQDk5PIvQkpq0GGkgNTmo-mjki63ZPgER_kovxq4',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(module coin GOVERNANCE\\n\\n  @doc \\"\'coin\' represents the Kadena Coin Contract. This contract provides both the \\\\\\n  \\\\buy/redeem gas support in the form of \'fund-tx\', as well as transfer,       \\\\\\n  \\\\credit, debit, coinbase, account creation and query, as well as SPV burn    \\\\\\n  \\\\create. To access the coin contract, you may use its fully-qualified name,  \\\\\\n  \\\\or issue the \'(use coin)\' command in the body of a module declaration.\\"\\n\\n  @model\\n    [ (defproperty conserves-mass\\n        (= (column-delta coin-table \'balance) 0.0))\\n\\n      (defproperty valid-account (account:string)\\n        (and\\n          (>= (length account) 3)\\n          (<= (length account) 256)))\\n    ]\\n\\n  (implements fungible-v1)\\n\\n  ; --------------------------------------------------------------------------\\n  ; Schemas and Tables\\n\\n  (defschema coin-schema\\n    @doc \\"The coin contract token schema\\"\\n    @model [ (invariant (>= balance 0.0)) ]\\n\\n    balance:decimal\\n    guard:guard)\\n\\n  (deftable coin-table:{coin-schema})\\n\\n  ; --------------------------------------------------------------------------\\n  ; Capabilities\\n\\n  (defcap GOVERNANCE ()\\n    (enforce false \\"Enforce non-upgradeability\\"))\\n\\n  (defcap GAS ()\\n    \\"Magic capability to protect gas buy and redeem\\"\\n    true)\\n\\n  (defcap COINBASE ()\\n    \\"Magic capability to protect miner reward\\"\\n    true)\\n\\n  (defcap GENESIS ()\\n    \\"Magic capability constraining genesis transactions\\"\\n    true)\\n\\n  (defcap DEBIT (sender:string)\\n    \\"Capability for managing debiting operations\\"\\n    (enforce-guard (at \'guard (read coin-table sender)))\\n    (enforce (!= sender \\"\\") \\"valid sender\\"))\\n\\n  (defcap CREDIT (receiver:string)\\n    \\"Capability for managing crediting operations\\"\\n    (enforce (!= receiver \\"\\") \\"valid receiver\\"))\\n\\n  (defcap TRANSFER:bool\\n    ( sender:string\\n      receiver:string\\n      amount:decimal\\n    )\\n    @managed amount TRANSFER-mgr\\n    (enforce (!= sender receiver) \\"same sender and receiver\\")\\n    (enforce-unit amount)\\n    (enforce (> amount 0.0) \\"Positive amount\\")\\n    (compose-capability (DEBIT sender))\\n    (compose-capability (CREDIT receiver))\\n  )\\n\\n  (defun TRANSFER-mgr:decimal\\n    ( managed:decimal\\n      requested:decimal\\n    )\\n\\n    (let ((newbal (- managed requested)))\\n      (enforce (>= newbal 0.0)\\n        (format \\"TRANSFER exceeded for balance {}\\" [managed]))\\n      newbal)\\n  )\\n\\n  ; --------------------------------------------------------------------------\\n  ; Constants\\n\\n  (defconst COIN_CHARSET CHARSET_LATIN1\\n    \\"The default coin contract character set\\")\\n\\n  (defconst MINIMUM_PRECISION 12\\n    \\"Minimum allowed precision for coin transactions\\")\\n\\n  (defconst MINIMUM_ACCOUNT_LENGTH 3\\n    \\"Minimum account length admissible for coin accounts\\")\\n\\n  (defconst MAXIMUM_ACCOUNT_LENGTH 256\\n    \\"Maximum account name length admissible for coin accounts\\")\\n\\n  ; --------------------------------------------------------------------------\\n  ; Utilities\\n\\n  (defun enforce-unit:bool (amount:decimal)\\n    @doc \\"Enforce minimum precision allowed for coin transactions\\"\\n\\n    (enforce\\n      (= (floor amount MINIMUM_PRECISION)\\n         amount)\\n      (format \\"Amount violates minimum precision: {}\\" [amount]))\\n    )\\n\\n  (defun validate-account (account:string)\\n    @doc \\"Enforce that an account name conforms to the coin contract \\\\\\n         \\\\minimum and maximum length requirements, as well as the    \\\\\\n         \\\\latin-1 character set.\\"\\n\\n    (enforce\\n      (is-charset COIN_CHARSET account)\\n      (format\\n        \\"Account does not conform to the coin contract charset: {}\\"\\n        [account]))\\n\\n    (let ((account-length (length account)))\\n\\n      (enforce\\n        (>= account-length MINIMUM_ACCOUNT_LENGTH)\\n        (format\\n          \\"Account name does not conform to the min length requirement: {}\\"\\n          [account]))\\n\\n      (enforce\\n        (<= account-length MAXIMUM_ACCOUNT_LENGTH)\\n        (format\\n          \\"Account name does not conform to the max length requirement: {}\\"\\n          [account]))\\n      )\\n  )\\n\\n  ; --------------------------------------------------------------------------\\n  ; Coin Contract\\n\\n  (defun gas-only ()\\n    \\"Predicate for gas-only user guards.\\"\\n    (require-capability (GAS)))\\n\\n  (defun gas-guard (guard:guard)\\n    \\"Predicate for gas + single key user guards\\"\\n    (enforce-one\\n      \\"Enforce either the presence of a GAS cap or keyset\\"\\n      [ (gas-only)\\n        (enforce-guard guard)\\n      ]))\\n\\n  (defun buy-gas:string (sender:string total:decimal)\\n    @doc \\"This function describes the main \'gas buy\' operation. At this point \\\\\\n    \\\\MINER has been chosen from the pool, and will be validated. The SENDER   \\\\\\n    \\\\of this transaction has specified a gas limit LIMIT (maximum gas) for    \\\\\\n    \\\\the transaction, and the price is the spot price of gas at that time.    \\\\\\n    \\\\The gas buy will be executed prior to executing SENDER\'s code.\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n           ]\\n\\n    (validate-account sender)\\n\\n    (enforce-unit total)\\n    (enforce (> total 0.0) \\"gas supply must be a positive quantity\\")\\n\\n    (require-capability (GAS))\\n    (with-capability (DEBIT sender)\\n      (debit sender total))\\n    )\\n\\n  (defun redeem-gas:string (miner:string miner-guard:guard sender:string total:decimal)\\n    @doc \\"This function describes the main \'redeem gas\' operation. At this    \\\\\\n    \\\\point, the SENDER\'s transaction has been executed, and the gas that      \\\\\\n    \\\\was charged has been calculated. MINER will be credited the gas cost,    \\\\\\n    \\\\and SENDER will receive the remainder up to the limit\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account miner))\\n           ]\\n\\n    (validate-account sender)\\n    (validate-account miner)\\n    (enforce-unit total)\\n\\n    (require-capability (GAS))\\n    (let*\\n      ((fee (read-decimal \\"fee\\"))\\n       (refund (- total fee)))\\n\\n      (enforce-unit fee)\\n      (enforce (>= fee 0.0)\\n        \\"fee must be a non-negative quantity\\")\\n\\n      (enforce (>= refund 0.0)\\n        \\"refund must be a non-negative quantity\\")\\n\\n        ; directly update instead of credit\\n      (with-capability (CREDIT sender)\\n        (if (> refund 0.0)\\n          (with-read coin-table sender\\n            { \\"balance\\" := balance }\\n            (update coin-table sender\\n              { \\"balance\\": (+ balance refund) }))\\n\\n          \\"noop\\"))\\n\\n      (with-capability (CREDIT miner)\\n        (if (> fee 0.0)\\n          (credit miner miner-guard fee)\\n          \\"noop\\"))\\n      )\\n\\n    )\\n\\n  (defun create-account:string (account:string guard:guard)\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n\\n    (insert coin-table account\\n      { \\"balance\\" : 0.0\\n      , \\"guard\\"   : guard\\n      })\\n    )\\n\\n  (defun get-balance:decimal (account:string)\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n      balance\\n      )\\n    )\\n\\n  (defun details:object{fungible-v1.account-details}\\n    ( account:string )\\n    (with-read coin-table account\\n      { \\"balance\\" := bal\\n      , \\"guard\\" := g }\\n      { \\"account\\" : account\\n      , \\"balance\\" : bal\\n      , \\"guard\\": g })\\n    )\\n\\n  (defun rotate:string (account:string new-guard:guard)\\n\\n    (with-read coin-table account\\n      { \\"guard\\" := old-guard }\\n\\n      (enforce-guard old-guard)\\n      (enforce-guard new-guard)\\n\\n      (update coin-table account\\n        { \\"guard\\" : new-guard }\\n        )))\\n\\n\\n  (defun precision:integer\\n    ()\\n    MINIMUM_PRECISION)\\n\\n  (defun transfer:string (sender:string receiver:string amount:decimal)\\n    @model [ (property conserves-mass)\\n             (property (> amount 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account receiver))\\n             (property (!= sender receiver)) ]\\n\\n    (enforce (!= sender receiver)\\n      \\"sender cannot be the receiver of a transfer\\")\\n\\n    (validate-account sender)\\n    (validate-account receiver)\\n\\n    (enforce (> amount 0.0)\\n      \\"transfer amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (with-capability (TRANSFER sender receiver amount)\\n      (debit sender amount)\\n      (with-read coin-table receiver\\n        { \\"guard\\" := g }\\n\\n        (credit receiver g amount))\\n      )\\n    )\\n\\n  (defun transfer-create:string\\n    ( sender:string\\n      receiver:string\\n      receiver-guard:guard\\n      amount:decimal )\\n\\n    @model [ (property conserves-mass) ]\\n\\n    (enforce (!= sender receiver)\\n      \\"sender cannot be the receiver of a transfer\\")\\n\\n    (validate-account sender)\\n    (validate-account receiver)\\n\\n    (enforce (> amount 0.0)\\n      \\"transfer amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (with-capability (TRANSFER sender receiver amount)\\n      (debit sender amount)\\n      (credit receiver receiver-guard amount))\\n    )\\n\\n  (defun coinbase:string (account:string account-guard:guard amount:decimal)\\n    @doc \\"Internal function for the initial creation of coins.  This function \\\\\\n    \\\\cannot be used outside of the coin contract.\\"\\n\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n    (enforce-unit amount)\\n\\n    (require-capability (COINBASE))\\n    (with-capability (CREDIT account)\\n      (credit account account-guard amount))\\n    )\\n\\n  (defpact fund-tx (sender:string miner:string miner-guard:guard total:decimal)\\n    @doc \\"\'fund-tx\' is a special pact to fund a transaction in two steps,     \\\\\\n    \\\\with the actual transaction transpiring in the middle:                   \\\\\\n    \\\\                                                                         \\\\\\n    \\\\  1) A buying phase, debiting the sender for total gas and fee, yielding \\\\\\n    \\\\     TX_MAX_CHARGE.                                                      \\\\\\n    \\\\  2) A settlement phase, resuming TX_MAX_CHARGE, and allocating to the   \\\\\\n    \\\\     coinbase account for used gas and fee, and sender account for bal-  \\\\\\n    \\\\     ance (unused gas, if any).\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account miner))\\n             ;(property conserves-mass) not supported yet\\n           ]\\n\\n    (step (buy-gas sender total))\\n    (step (redeem-gas miner miner-guard sender total))\\n    )\\n\\n  (defun debit:string (account:string amount:decimal)\\n    @doc \\"Debit AMOUNT from ACCOUNT balance\\"\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account account))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0)\\n      \\"debit amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (require-capability (DEBIT account))\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n\\n      (enforce (<= amount balance) \\"Insufficient funds\\")\\n\\n      (update coin-table account\\n        { \\"balance\\" : (- balance amount) }\\n        ))\\n    )\\n\\n\\n  (defun credit:string (account:string guard:guard amount:decimal)\\n    @doc \\"Credit AMOUNT to ACCOUNT balance\\"\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account account))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0) \\"credit amount must be positive\\")\\n    (enforce-unit amount)\\n\\n    (require-capability (CREDIT account))\\n    (with-default-read coin-table account\\n      { \\"balance\\" : 0.0, \\"guard\\" : guard }\\n      { \\"balance\\" := balance, \\"guard\\" := retg }\\n      ; we don\'t want to overwrite an existing guard with the user-supplied one\\n      (enforce (= retg guard)\\n        \\"account guards do not match\\")\\n\\n      (write coin-table account\\n        { \\"balance\\" : (+ balance amount)\\n        , \\"guard\\"   : retg\\n        })\\n      ))\\n\\n\\n  (defschema crosschain-schema\\n    @doc \\"Schema for yielded value in cross-chain transfers\\"\\n    receiver:string\\n    receiver-guard:guard\\n    amount:decimal)\\n\\n  (defpact transfer-crosschain:string\\n    ( sender:string\\n      receiver:string\\n      receiver-guard:guard\\n      target-chain:string\\n      amount:decimal )\\n\\n    @model [ (property (> amount 0.0))\\n             (property (!= receiver \\"\\"))\\n             (property (valid-account sender))\\n             (property (valid-account receiver))\\n           ]\\n\\n    (step\\n      (with-capability (DEBIT sender)\\n\\n        (validate-account sender)\\n        (validate-account receiver)\\n\\n        (enforce (!= \\"\\" target-chain) \\"empty target-chain\\")\\n        (enforce (!= (at \'chain-id (chain-data)) target-chain)\\n          \\"cannot run cross-chain transfers to the same chain\\")\\n\\n        (enforce (> amount 0.0)\\n          \\"transfer quantity must be positive\\")\\n\\n        (enforce-unit amount)\\n\\n        ;; step 1 - debit delete-account on current chain\\n        (debit sender amount)\\n\\n        (let\\n          ((crosschain-details:object{crosschain-schema}\\n            { \\"receiver\\" : receiver\\n            , \\"receiver-guard\\" : receiver-guard\\n            , \\"amount\\" : amount\\n            }))\\n          (yield crosschain-details target-chain)\\n          )))\\n\\n    (step\\n      (resume\\n        { \\"receiver\\" := receiver\\n        , \\"receiver-guard\\" := receiver-guard\\n        , \\"amount\\" := amount\\n        }\\n\\n        ;; step 2 - credit create account on target chain\\n        (with-capability (CREDIT receiver)\\n          (credit receiver receiver-guard amount))\\n        ))\\n    )\\n\\n\\n  ; --------------------------------------------------------------------------\\n  ; Coin allocations\\n\\n  (defschema allocation-schema\\n    @doc \\"Genesis allocation registry\\"\\n    ;@model [ (invariant (>= balance 0.0)) ]\\n\\n    balance:decimal\\n    date:time\\n    guard:guard\\n    redeemed:bool)\\n\\n  (deftable allocation-table:{allocation-schema})\\n\\n  (defun create-allocation-account\\n    ( account:string\\n      date:time\\n      keyset-ref:string\\n      amount:decimal\\n    )\\n\\n    @doc \\"Add an entry to the coin allocation table. This function \\\\\\n         \\\\also creates a corresponding empty coin contract account \\\\\\n         \\\\of the same name and guard. Requires GENESIS capability. \\"\\n\\n    @model [ (property (valid-account account)) ]\\n\\n    (require-capability (GENESIS))\\n\\n    (validate-account account)\\n    (enforce (>= amount 0.0)\\n      \\"allocation amount must be non-negative\\")\\n\\n    (enforce-unit amount)\\n\\n    (let\\n      ((guard:guard (keyset-ref-guard keyset-ref)))\\n\\n      (create-account account guard)\\n\\n      (insert allocation-table account\\n        { \\"balance\\" : amount\\n        , \\"date\\" : date\\n        , \\"guard\\" : guard\\n        , \\"redeemed\\" : false\\n        })))\\n\\n  (defun release-allocation\\n    ( account:string )\\n\\n    @doc \\"Release funds associated with allocation ACCOUNT into main ledger.   \\\\\\n         \\\\ACCOUNT must already exist in main ledger. Allocation is deactivated \\\\\\n         \\\\after release.\\"\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n\\n    (with-read allocation-table account\\n      { \\"balance\\" := balance\\n      , \\"date\\" := release-time\\n      , \\"redeemed\\" := redeemed\\n      , \\"guard\\" := guard\\n      }\\n\\n      (let ((curr-time:time (at \'block-time (chain-data))))\\n\\n        (enforce (not redeemed)\\n          \\"allocation funds have already been redeemed\\")\\n\\n        (enforce\\n          (>= curr-time release-time)\\n          (format \\"funds locked until {}. current time: {}\\" [release-time curr-time]))\\n\\n        (enforce-guard guard)\\n\\n        (with-capability (CREDIT account)\\n          (credit account guard balance)\\n\\n          (update allocation-table account\\n            { \\"redeemed\\" : true\\n            , \\"balance\\" : 0.0\\n            })\\n\\n          \\"Allocation successfully released to main ledger\\")\\n    )))\\n\\n)\\n\\n(create-table coin-table)\\n(create-table allocation-table)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"TableCreated"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozODAxMDY5Mg==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyIwOXFrOXVsd3RxODU0b2dKd2xEWktON05DX1EzbHFpeTFqZEQwX1l2V01JIiwiNDhUMExqQW5TRnBGV3h2dmFQVi1fNkUtQ2pEQVBoV1lVRldidnlmMmxGcyJd',
            hash: '48T0LjAnSFpFWxvvaPV-_6E-CjDAPhWYUFWbvyf2lFs',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface fungible-v1\\n\\n  \\" Standard for fungible coins and tokens as specified in KIP-0002. \\"\\n\\n   ; ----------------------------------------------------------------------\\n   ; Schema\\n\\n   (defschema account-details\\n    @doc \\"Schema for results of \'account\' operation.\\"\\n    @model [ (invariant (!= \\"\\" sender)) ]\\n\\n    account:string\\n    balance:decimal\\n    guard:guard)\\n\\n\\n   ; ----------------------------------------------------------------------\\n   ; Caps\\n\\n   (defcap TRANSFER:bool\\n     ( sender:string\\n       receiver:string\\n       amount:decimal\\n     )\\n     @doc \\" Managed capability sealing AMOUNT for transfer from SENDER to \\\\\\n          \\\\ RECEIVER. Permits any number of transfers up to AMOUNT.\\"\\n     @managed amount TRANSFER-mgr\\n     )\\n\\n   (defun TRANSFER-mgr:decimal\\n     ( managed:decimal\\n       requested:decimal\\n     )\\n     @doc \\" Manages TRANSFER AMOUNT linearly, \\\\\\n          \\\\ such that a request for 1.0 amount on a 3.0 \\\\\\n          \\\\ managed quantity emits updated amount 2.0.\\"\\n     )\\n\\n   ; ----------------------------------------------------------------------\\n   ; Functionality\\n\\n   (defun transfer-create:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       amount:decimal\\n     )\\n     @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n          \\\\ Fails if SENDER does not exist. If RECEIVER exists, guard \\\\\\n          \\\\ must match existing value. If RECEIVER does not exist, \\\\\\n          \\\\ RECEIVER account is created using RECEIVER-GUARD. \\\\\\n          \\\\ Subject to management by TRANSFER capability.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n            ]\\n     )\\n\\n   (defpact transfer-crosschain:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       target-chain:string\\n       amount:decimal\\n     )\\n     @doc \\" 2-step pact to transfer AMOUNT from SENDER on current chain \\\\\\n          \\\\ to RECEIVER on TARGET-CHAIN via SPV proof. \\\\\\n          \\\\ TARGET-CHAIN must be different than current chain id. \\\\\\n          \\\\ First step debits AMOUNT coins in SENDER account and yields \\\\\\n          \\\\ RECEIVER, RECEIVER_GUARD and AMOUNT to TARGET-CHAIN. \\\\\\n          \\\\ Second step continuation is sent into TARGET-CHAIN with proof \\\\\\n          \\\\ obtained from the spv \'output\' endpoint of Chainweb. \\\\\\n          \\\\ Proof is validated and RECEIVER is credited with AMOUNT \\\\\\n          \\\\ creating account with RECEIVER_GUARD as necessary.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n              (property (!= target-chain \\"\\"))\\n            ]\\n     )\\n\\n   (defun get-balance:decimal\\n     ( account:string )\\n     \\" Get balance for ACCOUNT. Fails if account does not exist.\\"\\n     )\\n\\n   (defun details:object{account-details}\\n     ( account: string )\\n     \\" Get an object with details of ACCOUNT. \\\\\\n     \\\\ Fails if account does not exist.\\"\\n     )\\n\\n   (defun precision:integer\\n     ()\\n     \\"Return the maximum allowed decimal precision.\\"\\n     )\\n\\n   (defun enforce-unit:bool\\n     ( amount:decimal )\\n     \\" Enforce minimum precision allowed for transactions.\\"\\n     )\\n\\n   (defun create-account:string\\n     ( account:string\\n       guard:guard\\n     )\\n     \\" Create ACCOUNT with 0.0 balance, with GUARD controlling access.\\"\\n     )\\n\\n   (defun rotate:string\\n     ( account:string\\n       new-guard:guard\\n     )\\n     \\" Rotate guard for ACCOUNT. Transaction is validated against \\\\\\n     \\\\ existing guard before installing new guard. \\"\\n     )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface fungible-v1"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozNzI5MjM0Mw==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJ0TXl5N2s2bHJRT3NHZzJvWGgyMGtPQzN6dWRqd3NhTDlGNU9neDBYTkJvIiwiU3o5NW1ZV093UTg3dVVRZjRmUGNJcEJzQXJlUUZxTmp2dGFKaExxS0p6YyJd',
            hash: 'Sz95mYWOwQ87uUQf4fPcIpBsAreQFqNjvtaJhLqKJzc',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(coin.create-allocation-account \\"PS_C3_1312\\" (time \\"2024-12-01T00:00:00Z\\") \\"PS_C3\\" 1200000.0)\\n(coin.create-allocation-account \\"PS_C3_1302\\" (time \\"2024-11-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1292\\" (time \\"2024-10-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1282\\" (time \\"2024-09-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1272\\" (time \\"2024-08-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1262\\" (time \\"2024-07-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1252\\" (time \\"2024-06-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1242\\" (time \\"2024-05-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1232\\" (time \\"2024-04-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1222\\" (time \\"2024-03-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1212\\" (time \\"2024-02-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1202\\" (time \\"2024-01-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1192\\" (time \\"2023-12-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1182\\" (time \\"2023-11-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1172\\" (time \\"2023-10-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1162\\" (time \\"2023-09-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1152\\" (time \\"2023-08-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1142\\" (time \\"2023-07-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1132\\" (time \\"2023-06-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1122\\" (time \\"2023-05-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1112\\" (time \\"2023-04-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1102\\" (time \\"2023-03-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1092\\" (time \\"2023-02-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1082\\" (time \\"2023-01-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1072\\" (time \\"2022-12-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1062\\" (time \\"2022-11-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1051\\" (time \\"2022-10-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1041\\" (time \\"2022-09-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1031\\" (time \\"2022-08-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1020\\" (time \\"2022-07-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1010\\" (time \\"2022-06-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_1000\\" (time \\"2022-05-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_989\\" (time \\"2022-04-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_979\\" (time \\"2022-03-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_969\\" (time \\"2022-02-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_958\\" (time \\"2022-01-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_947\\" (time \\"2021-12-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_936\\" (time \\"2021-11-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_924\\" (time \\"2021-10-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_913\\" (time \\"2021-09-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_902\\" (time \\"2021-08-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_890\\" (time \\"2021-07-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_879\\" (time \\"2021-06-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_868\\" (time \\"2021-05-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_855\\" (time \\"2021-04-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_843\\" (time \\"2021-03-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_831\\" (time \\"2021-02-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)\\n(coin.create-allocation-account \\"PS_C3_818\\" (time \\"2021-01-01T00:00:00Z\\") \\"PS_C3\\" 400000.0)"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Write succeeded"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozNzI5MjM0Mg==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJ0TXl5N2s2bHJRT3NHZzJvWGgyMGtPQzN6dWRqd3NhTDlGNU9neDBYTkJvIiwiNVFSSjlaMDZSWDM1MDJSal9FN1ZGMG4zRHBWSGdheElMNHV0S2FPZHN0QSJd',
            hash: '5QRJ9Z06RX3502Rj_E7VF0n3DpVHgaxIL4utKaOdstA',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(define-keyset \\"SA <1>\\" (read-keyset \\"SA <1>\\"))\\n(define-keyset \\"SA <2>\\" (read-keyset \\"SA <2>\\"))\\n(define-keyset \\"SA <3>\\" (read-keyset \\"SA <3>\\"))\\n(define-keyset \\"SA <4>\\" (read-keyset \\"SA <4>\\"))\\n(define-keyset \\"SA <5>\\" (read-keyset \\"SA <5>\\"))\\n(define-keyset \\"SA <6>\\" (read-keyset \\"SA <6>\\"))\\n(define-keyset \\"SA <7>\\" (read-keyset \\"SA <7>\\"))\\n(define-keyset \\"SA <8>\\" (read-keyset \\"SA <8>\\"))\\n(define-keyset \\"SA <9>\\" (read-keyset \\"SA <9>\\"))\\n(define-keyset \\"SA <10>\\" (read-keyset \\"SA <10>\\"))\\n(define-keyset \\"SA <11>\\" (read-keyset \\"SA <11>\\"))\\n(define-keyset \\"SA <12>\\" (read-keyset \\"SA <12>\\"))\\n(define-keyset \\"SA <13>\\" (read-keyset \\"SA <13>\\"))\\n(define-keyset \\"SA <14>\\" (read-keyset \\"SA <14>\\"))\\n(define-keyset \\"SA <15>\\" (read-keyset \\"SA <15>\\"))\\n(define-keyset \\"SA <16>\\" (read-keyset \\"SA <16>\\"))\\n(define-keyset \\"SA <17>\\" (read-keyset \\"SA <17>\\"))\\n(define-keyset \\"SA <18>\\" (read-keyset \\"SA <18>\\"))\\n(define-keyset \\"SA <19>\\" (read-keyset \\"SA <19>\\"))\\n(define-keyset \\"SA <20>\\" (read-keyset \\"SA <20>\\"))\\n(define-keyset \\"SB <1>\\" (read-keyset \\"SB <1>\\"))\\n(define-keyset \\"SB <2>\\" (read-keyset \\"SB <2>\\"))\\n(define-keyset \\"SB <3>\\" (read-keyset \\"SB <3>\\"))\\n(define-keyset \\"SB <4>\\" (read-keyset \\"SB <4>\\"))\\n(define-keyset \\"SB <5>\\" (read-keyset \\"SB <5>\\"))\\n(define-keyset \\"SB <6>\\" (read-keyset \\"SB <6>\\"))\\n(define-keyset \\"SB <7>\\" (read-keyset \\"SB <7>\\"))\\n(define-keyset \\"SB <8>\\" (read-keyset \\"SB <8>\\"))\\n(define-keyset \\"SB <9>\\" (read-keyset \\"SB <9>\\"))\\n(define-keyset \\"SB <10>\\" (read-keyset \\"SB <10>\\"))\\n(define-keyset \\"SB <11>\\" (read-keyset \\"SB <11>\\"))\\n(define-keyset \\"SB <12>\\" (read-keyset \\"SB <12>\\"))\\n(define-keyset \\"SB <13>\\" (read-keyset \\"SB <13>\\"))\\n(define-keyset \\"SB <14>\\" (read-keyset \\"SB <14>\\"))\\n(define-keyset \\"SB <15>\\" (read-keyset \\"SB <15>\\"))\\n(define-keyset \\"SB <16>\\" (read-keyset \\"SB <16>\\"))\\n(define-keyset \\"SB <17>\\" (read-keyset \\"SB <17>\\"))\\n(define-keyset \\"SB <18>\\" (read-keyset \\"SB <18>\\"))\\n(define-keyset \\"SB <19>\\" (read-keyset \\"SB <19>\\"))\\n(define-keyset \\"SB <20>\\" (read-keyset \\"SB <20>\\"))\\n(define-keyset \\"SB <21>\\" (read-keyset \\"SB <21>\\"))\\n(define-keyset \\"SB <22>\\" (read-keyset \\"SB <22>\\"))\\n(define-keyset \\"SB <23>\\" (read-keyset \\"SB <23>\\"))\\n(define-keyset \\"SB <24>\\" (read-keyset \\"SB <24>\\"))\\n(define-keyset \\"SB <25>\\" (read-keyset \\"SB <25>\\"))\\n(define-keyset \\"SB <26>\\" (read-keyset \\"SB <26>\\"))\\n(define-keyset \\"SB <27>\\" (read-keyset \\"SB <27>\\"))\\n(define-keyset \\"SB <28>\\" (read-keyset \\"SB <28>\\"))\\n(define-keyset \\"SB <29>\\" (read-keyset \\"SB <29>\\"))\\n(define-keyset \\"SB <30>\\" (read-keyset \\"SB <30>\\"))\\n(define-keyset \\"SB <31>\\" (read-keyset \\"SB <31>\\"))\\n(define-keyset \\"SB <32>\\" (read-keyset \\"SB <32>\\"))\\n(define-keyset \\"SB <33>\\" (read-keyset \\"SB <33>\\"))\\n(define-keyset \\"SB <34>\\" (read-keyset \\"SB <34>\\"))\\n(define-keyset \\"SB <35>\\" (read-keyset \\"SB <35>\\"))\\n(define-keyset \\"SB <36>\\" (read-keyset \\"SB <36>\\"))\\n(define-keyset \\"SB <37>\\" (read-keyset \\"SB <37>\\"))\\n(define-keyset \\"SB <38>\\" (read-keyset \\"SB <38>\\"))\\n(define-keyset \\"SB <39>\\" (read-keyset \\"SB <39>\\"))\\n(define-keyset \\"SB <40>\\" (read-keyset \\"SB <40>\\"))\\n(define-keyset \\"SB <41>\\" (read-keyset \\"SB <41>\\"))\\n(define-keyset \\"SB <42>\\" (read-keyset \\"SB <42>\\"))\\n(define-keyset \\"SB <43>\\" (read-keyset \\"SB <43>\\"))\\n(define-keyset \\"SB <44>\\" (read-keyset \\"SB <44>\\"))\\n(define-keyset \\"SB <45>\\" (read-keyset \\"SB <45>\\"))\\n(define-keyset \\"SB <46>\\" (read-keyset \\"SB <46>\\"))\\n(define-keyset \\"PS_C0\\" (read-keyset \\"PS_C0\\"))\\n(define-keyset \\"PS_C1\\" (read-keyset \\"PS_C1\\"))\\n(define-keyset \\"PS_C2\\" (read-keyset \\"PS_C2\\"))\\n(define-keyset \\"PS_C3\\" (read-keyset \\"PS_C3\\"))\\n(define-keyset \\"PS_C4\\" (read-keyset \\"PS_C4\\"))\\n(define-keyset \\"PS_C5\\" (read-keyset \\"PS_C5\\"))\\n(define-keyset \\"PS_C6\\" (read-keyset \\"PS_C6\\"))\\n(define-keyset \\"PS_C7\\" (read-keyset \\"PS_C7\\"))\\n(define-keyset \\"PS_C8\\" (read-keyset \\"PS_C8\\"))\\n(define-keyset \\"PS_C9\\" (read-keyset \\"PS_C9\\"))\\n(define-keyset \\"EB_C9\\" (read-keyset \\"EB_C9\\"))\\n(define-keyset \\"Coinlist Non-US\\" (read-keyset \\"Coinlist Non-US\\"))\\n(define-keyset \\"Coinlist Global\\" (read-keyset \\"Coinlist Global\\"))\\n(define-keyset \\"FTS_C1\\" (read-keyset \\"FTS_C1\\"))\\n(define-keyset \\"CS1_C2\\" (read-keyset \\"CS1_C2\\"))\\n(define-keyset \\"CS2_C0\\" (read-keyset \\"CS2_C0\\"))\\n(define-keyset \\"ST_C1\\" (read-keyset \\"ST_C1\\"))"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Keyset defined"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozNzI5MjM0MQ==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJ0TXl5N2s2bHJRT3NHZzJvWGgyMGtPQzN6dWRqd3NhTDlGNU9neDBYTkJvIiwiRC1tY0VzMWJycE1OTloxTkx5a2haNEo5cFdFcHJYQmh1V2hDbWZFYUR0VSJd',
            hash: 'D-mcEs1brpMNNZ1NLykhZ4J9pWEprXBhuWhCmfEaDtU',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"\\n(define-keyset \'ns-admin-keyset (read-keyset \'ns-admin-keyset))\\n(define-keyset \'ns-operate-keyset (read-keyset \'ns-genesis-keyset))\\n\\n(module ns GOVERNANCE\\n  \\"Administers definition of new namespaces in Chainweb.\\"\\n\\n  (defschema reg-entry\\n    admin-guard:guard\\n    active:bool)\\n\\n  (deftable registry:{reg-entry})\\n\\n  (defcap GOVERNANCE ()\\n    (enforce-keyset \'ns-admin-keyset))\\n\\n  (defcap OPERATE ()\\n    (enforce-keyset \'ns-operate-keyset))\\n\\n  (defconst GUARD_SUCCESS (create-user-guard (success)))\\n  (defconst GUARD_FAILURE (create-user-guard (failure)))\\n\\n  (defun success ()\\n    true)\\n  (defun failure ()\\n    (enforce false \\"Disabled\\"))\\n\\n  (defun validate-name (name)\\n    (enforce (!= \\"\\" name) \\"Empty name not allowed\\")\\n    (enforce (< (length name) 64) \\"Name must be less than 64 characters long\\")\\n    (enforce (is-charset CHARSET_LATIN1 name)\\n             \\"Name must be in latin1 charset\\"))\\n\\n  (defun validate:bool\\n      ( ns-name:string\\n        ns-admin:guard\\n        )\\n    \\" Manages namespace install for Chainweb. Requires active row in registry \\\\\\n    \\\\ for NS-NAME with guard matching NS-ADMIN.\\"\\n\\n    (validate-name ns-name)\\n\\n    (with-default-read registry ns-name\\n      { \'admin-guard : ns-admin\\n      , \'active : false }\\n      { \'admin-guard := ag\\n      , \'active := is-active }\\n\\n        (enforce is-active \\"Inactive or unregistered namespace\\")\\n        (enforce (= ns-admin ag) \\"Admin guard must match guard in registry\\")\\n\\n        true))\\n\\n  (defun write-registry:string\\n      ( ns-name:string\\n        guard:guard\\n        active:bool\\n        )\\n    \\" Write entry with GUARD and ACTIVE into registry for NAME. \\\\\\n    \\\\ Guarded by operate keyset. \\"\\n\\n    (with-capability (OPERATE)\\n\\n      (validate-name ns-name)\\n\\n      (write registry ns-name\\n        { \'admin-guard: guard\\n        , \'active: active })\\n\\n      \\"Register entry written\\"))\\n\\n  (defun query:object{reg-entry}\\n      ( ns-name:string )\\n    (read registry ns-name))\\n\\n  )\\n\\n(create-table registry)\\n\\n(write-registry \\"kadena\\"\\n  (keyset-ref-guard \'ns-operate-keyset) true)\\n(write-registry \\"user\\" GUARD_FAILURE true)\\n(write-registry \\"free\\" GUARD_FAILURE true)\\n\\n(define-namespace \\"kadena\\"\\n  (keyset-ref-guard \'ns-operate-keyset)\\n  (keyset-ref-guard \'ns-operate-keyset))\\n\\n(define-namespace \\"user\\" GUARD_SUCCESS GUARD_FAILURE)\\n(define-namespace \\"free\\" GUARD_SUCCESS GUARD_FAILURE)\\n;;rotate to real operate keyset\\n(define-keyset \'ns-operate-keyset (read-keyset \'ns-operate-keyset))\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Keyset defined"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozNzI5MjM0MA==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJ0TXl5N2s2bHJRT3NHZzJvWGgyMGtPQzN6dWRqd3NhTDlGNU9neDBYTkJvIiwiU0IzVzVFTGl6azl4elNWWk9MX3dsem5VNjh5aUhPQzlwWUhreHBVXzBnbyJd',
            hash: 'SB3W5ELizk9xzSVZOL_wlznU68yiHOC9pYHkxpU_0go',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface gas-payer-v1\\n\\n  (defcap GAS_PAYER:bool\\n    ( user:string\\n      limit:integer\\n      price:decimal\\n    )\\n    @doc\\n    \\" Provide a capability indicating that declaring module supports \\\\\\n    \\\\ gas payment for USER for gas LIMIT and PRICE. Functionality \\\\\\n    \\\\ should require capability (coin.FUND_TX), and should validate \\\\\\n    \\\\ the spend of (limit * price), possibly updating some database \\\\\\n    \\\\ entry. \\\\\\n    \\\\ Should compose capability required for \'create-gas-payer-guard\'.\\"\\n    @model\\n    [ (property (user != \\"\\"))\\n      (property (limit > 0))\\n      (property (price > 0.0))\\n    ]\\n  )\\n\\n  (defun create-gas-payer-guard:guard ()\\n    @doc\\n    \\" Provide a guard suitable for controlling a coin account that can \\\\\\n    \\\\ pay gas via GAS_PAYER mechanics. Generally this is accomplished \\\\\\n    \\\\ by having GAS_PAYER compose an unparameterized, unmanaged capability \\\\\\n    \\\\ that is required in this guard. Thus, if coin contract is able to \\\\\\n    \\\\ successfully acquire GAS_PAYER, the composed \'anonymous\' cap required \\\\\\n    \\\\ here will be in scope, and gas buy will succeed.\\"\\n  )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface gas-payer-v1"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozNzI5MjMzOQ==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJ0TXl5N2s2bHJRT3NHZzJvWGgyMGtPQzN6dWRqd3NhTDlGNU9neDBYTkJvIiwiWEdQRVFEazVQSXZRa3BxMEdHa2dOVG1vLW1qa2k2M1pQZ0VSX2tvdnhxNCJd',
            hash: 'XGPEQDk5PIvQkpq0GGkgNTmo-mjki63ZPgER_kovxq4',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(module coin GOVERNANCE\\n\\n  @doc \\"\'coin\' represents the Kadena Coin Contract. This contract provides both the \\\\\\n  \\\\buy/redeem gas support in the form of \'fund-tx\', as well as transfer,       \\\\\\n  \\\\credit, debit, coinbase, account creation and query, as well as SPV burn    \\\\\\n  \\\\create. To access the coin contract, you may use its fully-qualified name,  \\\\\\n  \\\\or issue the \'(use coin)\' command in the body of a module declaration.\\"\\n\\n  @model\\n    [ (defproperty conserves-mass\\n        (= (column-delta coin-table \'balance) 0.0))\\n\\n      (defproperty valid-account (account:string)\\n        (and\\n          (>= (length account) 3)\\n          (<= (length account) 256)))\\n    ]\\n\\n  (implements fungible-v1)\\n\\n  ; --------------------------------------------------------------------------\\n  ; Schemas and Tables\\n\\n  (defschema coin-schema\\n    @doc \\"The coin contract token schema\\"\\n    @model [ (invariant (>= balance 0.0)) ]\\n\\n    balance:decimal\\n    guard:guard)\\n\\n  (deftable coin-table:{coin-schema})\\n\\n  ; --------------------------------------------------------------------------\\n  ; Capabilities\\n\\n  (defcap GOVERNANCE ()\\n    (enforce false \\"Enforce non-upgradeability\\"))\\n\\n  (defcap GAS ()\\n    \\"Magic capability to protect gas buy and redeem\\"\\n    true)\\n\\n  (defcap COINBASE ()\\n    \\"Magic capability to protect miner reward\\"\\n    true)\\n\\n  (defcap GENESIS ()\\n    \\"Magic capability constraining genesis transactions\\"\\n    true)\\n\\n  (defcap DEBIT (sender:string)\\n    \\"Capability for managing debiting operations\\"\\n    (enforce-guard (at \'guard (read coin-table sender)))\\n    (enforce (!= sender \\"\\") \\"valid sender\\"))\\n\\n  (defcap CREDIT (receiver:string)\\n    \\"Capability for managing crediting operations\\"\\n    (enforce (!= receiver \\"\\") \\"valid receiver\\"))\\n\\n  (defcap TRANSFER:bool\\n    ( sender:string\\n      receiver:string\\n      amount:decimal\\n    )\\n    @managed amount TRANSFER-mgr\\n    (enforce (!= sender receiver) \\"same sender and receiver\\")\\n    (enforce-unit amount)\\n    (enforce (> amount 0.0) \\"Positive amount\\")\\n    (compose-capability (DEBIT sender))\\n    (compose-capability (CREDIT receiver))\\n  )\\n\\n  (defun TRANSFER-mgr:decimal\\n    ( managed:decimal\\n      requested:decimal\\n    )\\n\\n    (let ((newbal (- managed requested)))\\n      (enforce (>= newbal 0.0)\\n        (format \\"TRANSFER exceeded for balance {}\\" [managed]))\\n      newbal)\\n  )\\n\\n  ; --------------------------------------------------------------------------\\n  ; Constants\\n\\n  (defconst COIN_CHARSET CHARSET_LATIN1\\n    \\"The default coin contract character set\\")\\n\\n  (defconst MINIMUM_PRECISION 12\\n    \\"Minimum allowed precision for coin transactions\\")\\n\\n  (defconst MINIMUM_ACCOUNT_LENGTH 3\\n    \\"Minimum account length admissible for coin accounts\\")\\n\\n  (defconst MAXIMUM_ACCOUNT_LENGTH 256\\n    \\"Maximum account name length admissible for coin accounts\\")\\n\\n  ; --------------------------------------------------------------------------\\n  ; Utilities\\n\\n  (defun enforce-unit:bool (amount:decimal)\\n    @doc \\"Enforce minimum precision allowed for coin transactions\\"\\n\\n    (enforce\\n      (= (floor amount MINIMUM_PRECISION)\\n         amount)\\n      (format \\"Amount violates minimum precision: {}\\" [amount]))\\n    )\\n\\n  (defun validate-account (account:string)\\n    @doc \\"Enforce that an account name conforms to the coin contract \\\\\\n         \\\\minimum and maximum length requirements, as well as the    \\\\\\n         \\\\latin-1 character set.\\"\\n\\n    (enforce\\n      (is-charset COIN_CHARSET account)\\n      (format\\n        \\"Account does not conform to the coin contract charset: {}\\"\\n        [account]))\\n\\n    (let ((account-length (length account)))\\n\\n      (enforce\\n        (>= account-length MINIMUM_ACCOUNT_LENGTH)\\n        (format\\n          \\"Account name does not conform to the min length requirement: {}\\"\\n          [account]))\\n\\n      (enforce\\n        (<= account-length MAXIMUM_ACCOUNT_LENGTH)\\n        (format\\n          \\"Account name does not conform to the max length requirement: {}\\"\\n          [account]))\\n      )\\n  )\\n\\n  ; --------------------------------------------------------------------------\\n  ; Coin Contract\\n\\n  (defun gas-only ()\\n    \\"Predicate for gas-only user guards.\\"\\n    (require-capability (GAS)))\\n\\n  (defun gas-guard (guard:guard)\\n    \\"Predicate for gas + single key user guards\\"\\n    (enforce-one\\n      \\"Enforce either the presence of a GAS cap or keyset\\"\\n      [ (gas-only)\\n        (enforce-guard guard)\\n      ]))\\n\\n  (defun buy-gas:string (sender:string total:decimal)\\n    @doc \\"This function describes the main \'gas buy\' operation. At this point \\\\\\n    \\\\MINER has been chosen from the pool, and will be validated. The SENDER   \\\\\\n    \\\\of this transaction has specified a gas limit LIMIT (maximum gas) for    \\\\\\n    \\\\the transaction, and the price is the spot price of gas at that time.    \\\\\\n    \\\\The gas buy will be executed prior to executing SENDER\'s code.\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n           ]\\n\\n    (validate-account sender)\\n\\n    (enforce-unit total)\\n    (enforce (> total 0.0) \\"gas supply must be a positive quantity\\")\\n\\n    (require-capability (GAS))\\n    (with-capability (DEBIT sender)\\n      (debit sender total))\\n    )\\n\\n  (defun redeem-gas:string (miner:string miner-guard:guard sender:string total:decimal)\\n    @doc \\"This function describes the main \'redeem gas\' operation. At this    \\\\\\n    \\\\point, the SENDER\'s transaction has been executed, and the gas that      \\\\\\n    \\\\was charged has been calculated. MINER will be credited the gas cost,    \\\\\\n    \\\\and SENDER will receive the remainder up to the limit\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account miner))\\n           ]\\n\\n    (validate-account sender)\\n    (validate-account miner)\\n    (enforce-unit total)\\n\\n    (require-capability (GAS))\\n    (let*\\n      ((fee (read-decimal \\"fee\\"))\\n       (refund (- total fee)))\\n\\n      (enforce-unit fee)\\n      (enforce (>= fee 0.0)\\n        \\"fee must be a non-negative quantity\\")\\n\\n      (enforce (>= refund 0.0)\\n        \\"refund must be a non-negative quantity\\")\\n\\n        ; directly update instead of credit\\n      (with-capability (CREDIT sender)\\n        (if (> refund 0.0)\\n          (with-read coin-table sender\\n            { \\"balance\\" := balance }\\n            (update coin-table sender\\n              { \\"balance\\": (+ balance refund) }))\\n\\n          \\"noop\\"))\\n\\n      (with-capability (CREDIT miner)\\n        (if (> fee 0.0)\\n          (credit miner miner-guard fee)\\n          \\"noop\\"))\\n      )\\n\\n    )\\n\\n  (defun create-account:string (account:string guard:guard)\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n\\n    (insert coin-table account\\n      { \\"balance\\" : 0.0\\n      , \\"guard\\"   : guard\\n      })\\n    )\\n\\n  (defun get-balance:decimal (account:string)\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n      balance\\n      )\\n    )\\n\\n  (defun details:object{fungible-v1.account-details}\\n    ( account:string )\\n    (with-read coin-table account\\n      { \\"balance\\" := bal\\n      , \\"guard\\" := g }\\n      { \\"account\\" : account\\n      , \\"balance\\" : bal\\n      , \\"guard\\": g })\\n    )\\n\\n  (defun rotate:string (account:string new-guard:guard)\\n\\n    (with-read coin-table account\\n      { \\"guard\\" := old-guard }\\n\\n      (enforce-guard old-guard)\\n      (enforce-guard new-guard)\\n\\n      (update coin-table account\\n        { \\"guard\\" : new-guard }\\n        )))\\n\\n\\n  (defun precision:integer\\n    ()\\n    MINIMUM_PRECISION)\\n\\n  (defun transfer:string (sender:string receiver:string amount:decimal)\\n    @model [ (property conserves-mass)\\n             (property (> amount 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account receiver))\\n             (property (!= sender receiver)) ]\\n\\n    (enforce (!= sender receiver)\\n      \\"sender cannot be the receiver of a transfer\\")\\n\\n    (validate-account sender)\\n    (validate-account receiver)\\n\\n    (enforce (> amount 0.0)\\n      \\"transfer amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (with-capability (TRANSFER sender receiver amount)\\n      (debit sender amount)\\n      (with-read coin-table receiver\\n        { \\"guard\\" := g }\\n\\n        (credit receiver g amount))\\n      )\\n    )\\n\\n  (defun transfer-create:string\\n    ( sender:string\\n      receiver:string\\n      receiver-guard:guard\\n      amount:decimal )\\n\\n    @model [ (property conserves-mass) ]\\n\\n    (enforce (!= sender receiver)\\n      \\"sender cannot be the receiver of a transfer\\")\\n\\n    (validate-account sender)\\n    (validate-account receiver)\\n\\n    (enforce (> amount 0.0)\\n      \\"transfer amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (with-capability (TRANSFER sender receiver amount)\\n      (debit sender amount)\\n      (credit receiver receiver-guard amount))\\n    )\\n\\n  (defun coinbase:string (account:string account-guard:guard amount:decimal)\\n    @doc \\"Internal function for the initial creation of coins.  This function \\\\\\n    \\\\cannot be used outside of the coin contract.\\"\\n\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n    (enforce-unit amount)\\n\\n    (require-capability (COINBASE))\\n    (with-capability (CREDIT account)\\n      (credit account account-guard amount))\\n    )\\n\\n  (defpact fund-tx (sender:string miner:string miner-guard:guard total:decimal)\\n    @doc \\"\'fund-tx\' is a special pact to fund a transaction in two steps,     \\\\\\n    \\\\with the actual transaction transpiring in the middle:                   \\\\\\n    \\\\                                                                         \\\\\\n    \\\\  1) A buying phase, debiting the sender for total gas and fee, yielding \\\\\\n    \\\\     TX_MAX_CHARGE.                                                      \\\\\\n    \\\\  2) A settlement phase, resuming TX_MAX_CHARGE, and allocating to the   \\\\\\n    \\\\     coinbase account for used gas and fee, and sender account for bal-  \\\\\\n    \\\\     ance (unused gas, if any).\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account miner))\\n             ;(property conserves-mass) not supported yet\\n           ]\\n\\n    (step (buy-gas sender total))\\n    (step (redeem-gas miner miner-guard sender total))\\n    )\\n\\n  (defun debit:string (account:string amount:decimal)\\n    @doc \\"Debit AMOUNT from ACCOUNT balance\\"\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account account))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0)\\n      \\"debit amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (require-capability (DEBIT account))\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n\\n      (enforce (<= amount balance) \\"Insufficient funds\\")\\n\\n      (update coin-table account\\n        { \\"balance\\" : (- balance amount) }\\n        ))\\n    )\\n\\n\\n  (defun credit:string (account:string guard:guard amount:decimal)\\n    @doc \\"Credit AMOUNT to ACCOUNT balance\\"\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account account))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0) \\"credit amount must be positive\\")\\n    (enforce-unit amount)\\n\\n    (require-capability (CREDIT account))\\n    (with-default-read coin-table account\\n      { \\"balance\\" : 0.0, \\"guard\\" : guard }\\n      { \\"balance\\" := balance, \\"guard\\" := retg }\\n      ; we don\'t want to overwrite an existing guard with the user-supplied one\\n      (enforce (= retg guard)\\n        \\"account guards do not match\\")\\n\\n      (write coin-table account\\n        { \\"balance\\" : (+ balance amount)\\n        , \\"guard\\"   : retg\\n        })\\n      ))\\n\\n\\n  (defschema crosschain-schema\\n    @doc \\"Schema for yielded value in cross-chain transfers\\"\\n    receiver:string\\n    receiver-guard:guard\\n    amount:decimal)\\n\\n  (defpact transfer-crosschain:string\\n    ( sender:string\\n      receiver:string\\n      receiver-guard:guard\\n      target-chain:string\\n      amount:decimal )\\n\\n    @model [ (property (> amount 0.0))\\n             (property (!= receiver \\"\\"))\\n             (property (valid-account sender))\\n             (property (valid-account receiver))\\n           ]\\n\\n    (step\\n      (with-capability (DEBIT sender)\\n\\n        (validate-account sender)\\n        (validate-account receiver)\\n\\n        (enforce (!= \\"\\" target-chain) \\"empty target-chain\\")\\n        (enforce (!= (at \'chain-id (chain-data)) target-chain)\\n          \\"cannot run cross-chain transfers to the same chain\\")\\n\\n        (enforce (> amount 0.0)\\n          \\"transfer quantity must be positive\\")\\n\\n        (enforce-unit amount)\\n\\n        ;; step 1 - debit delete-account on current chain\\n        (debit sender amount)\\n\\n        (let\\n          ((crosschain-details:object{crosschain-schema}\\n            { \\"receiver\\" : receiver\\n            , \\"receiver-guard\\" : receiver-guard\\n            , \\"amount\\" : amount\\n            }))\\n          (yield crosschain-details target-chain)\\n          )))\\n\\n    (step\\n      (resume\\n        { \\"receiver\\" := receiver\\n        , \\"receiver-guard\\" := receiver-guard\\n        , \\"amount\\" := amount\\n        }\\n\\n        ;; step 2 - credit create account on target chain\\n        (with-capability (CREDIT receiver)\\n          (credit receiver receiver-guard amount))\\n        ))\\n    )\\n\\n\\n  ; --------------------------------------------------------------------------\\n  ; Coin allocations\\n\\n  (defschema allocation-schema\\n    @doc \\"Genesis allocation registry\\"\\n    ;@model [ (invariant (>= balance 0.0)) ]\\n\\n    balance:decimal\\n    date:time\\n    guard:guard\\n    redeemed:bool)\\n\\n  (deftable allocation-table:{allocation-schema})\\n\\n  (defun create-allocation-account\\n    ( account:string\\n      date:time\\n      keyset-ref:string\\n      amount:decimal\\n    )\\n\\n    @doc \\"Add an entry to the coin allocation table. This function \\\\\\n         \\\\also creates a corresponding empty coin contract account \\\\\\n         \\\\of the same name and guard. Requires GENESIS capability. \\"\\n\\n    @model [ (property (valid-account account)) ]\\n\\n    (require-capability (GENESIS))\\n\\n    (validate-account account)\\n    (enforce (>= amount 0.0)\\n      \\"allocation amount must be non-negative\\")\\n\\n    (enforce-unit amount)\\n\\n    (let\\n      ((guard:guard (keyset-ref-guard keyset-ref)))\\n\\n      (create-account account guard)\\n\\n      (insert allocation-table account\\n        { \\"balance\\" : amount\\n        , \\"date\\" : date\\n        , \\"guard\\" : guard\\n        , \\"redeemed\\" : false\\n        })))\\n\\n  (defun release-allocation\\n    ( account:string )\\n\\n    @doc \\"Release funds associated with allocation ACCOUNT into main ledger.   \\\\\\n         \\\\ACCOUNT must already exist in main ledger. Allocation is deactivated \\\\\\n         \\\\after release.\\"\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n\\n    (with-read allocation-table account\\n      { \\"balance\\" := balance\\n      , \\"date\\" := release-time\\n      , \\"redeemed\\" := redeemed\\n      , \\"guard\\" := guard\\n      }\\n\\n      (let ((curr-time:time (at \'block-time (chain-data))))\\n\\n        (enforce (not redeemed)\\n          \\"allocation funds have already been redeemed\\")\\n\\n        (enforce\\n          (>= curr-time release-time)\\n          (format \\"funds locked until {}. current time: {}\\" [release-time curr-time]))\\n\\n        (enforce-guard guard)\\n\\n        (with-capability (CREDIT account)\\n          (credit account guard balance)\\n\\n          (update allocation-table account\\n            { \\"redeemed\\" : true\\n            , \\"balance\\" : 0.0\\n            })\\n\\n          \\"Allocation successfully released to main ledger\\")\\n    )))\\n\\n)\\n\\n(create-table coin-table)\\n(create-table allocation-table)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"TableCreated"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozNzI5MjMzOA==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJ0TXl5N2s2bHJRT3NHZzJvWGgyMGtPQzN6dWRqd3NhTDlGNU9neDBYTkJvIiwiNDhUMExqQW5TRnBGV3h2dmFQVi1fNkUtQ2pEQVBoV1lVRldidnlmMmxGcyJd',
            hash: '48T0LjAnSFpFWxvvaPV-_6E-CjDAPhWYUFWbvyf2lFs',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface fungible-v1\\n\\n  \\" Standard for fungible coins and tokens as specified in KIP-0002. \\"\\n\\n   ; ----------------------------------------------------------------------\\n   ; Schema\\n\\n   (defschema account-details\\n    @doc \\"Schema for results of \'account\' operation.\\"\\n    @model [ (invariant (!= \\"\\" sender)) ]\\n\\n    account:string\\n    balance:decimal\\n    guard:guard)\\n\\n\\n   ; ----------------------------------------------------------------------\\n   ; Caps\\n\\n   (defcap TRANSFER:bool\\n     ( sender:string\\n       receiver:string\\n       amount:decimal\\n     )\\n     @doc \\" Managed capability sealing AMOUNT for transfer from SENDER to \\\\\\n          \\\\ RECEIVER. Permits any number of transfers up to AMOUNT.\\"\\n     @managed amount TRANSFER-mgr\\n     )\\n\\n   (defun TRANSFER-mgr:decimal\\n     ( managed:decimal\\n       requested:decimal\\n     )\\n     @doc \\" Manages TRANSFER AMOUNT linearly, \\\\\\n          \\\\ such that a request for 1.0 amount on a 3.0 \\\\\\n          \\\\ managed quantity emits updated amount 2.0.\\"\\n     )\\n\\n   ; ----------------------------------------------------------------------\\n   ; Functionality\\n\\n   (defun transfer-create:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       amount:decimal\\n     )\\n     @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n          \\\\ Fails if SENDER does not exist. If RECEIVER exists, guard \\\\\\n          \\\\ must match existing value. If RECEIVER does not exist, \\\\\\n          \\\\ RECEIVER account is created using RECEIVER-GUARD. \\\\\\n          \\\\ Subject to management by TRANSFER capability.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n            ]\\n     )\\n\\n   (defpact transfer-crosschain:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       target-chain:string\\n       amount:decimal\\n     )\\n     @doc \\" 2-step pact to transfer AMOUNT from SENDER on current chain \\\\\\n          \\\\ to RECEIVER on TARGET-CHAIN via SPV proof. \\\\\\n          \\\\ TARGET-CHAIN must be different than current chain id. \\\\\\n          \\\\ First step debits AMOUNT coins in SENDER account and yields \\\\\\n          \\\\ RECEIVER, RECEIVER_GUARD and AMOUNT to TARGET-CHAIN. \\\\\\n          \\\\ Second step continuation is sent into TARGET-CHAIN with proof \\\\\\n          \\\\ obtained from the spv \'output\' endpoint of Chainweb. \\\\\\n          \\\\ Proof is validated and RECEIVER is credited with AMOUNT \\\\\\n          \\\\ creating account with RECEIVER_GUARD as necessary.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n              (property (!= target-chain \\"\\"))\\n            ]\\n     )\\n\\n   (defun get-balance:decimal\\n     ( account:string )\\n     \\" Get balance for ACCOUNT. Fails if account does not exist.\\"\\n     )\\n\\n   (defun details:object{account-details}\\n     ( account: string )\\n     \\" Get an object with details of ACCOUNT. \\\\\\n     \\\\ Fails if account does not exist.\\"\\n     )\\n\\n   (defun precision:integer\\n     ()\\n     \\"Return the maximum allowed decimal precision.\\"\\n     )\\n\\n   (defun enforce-unit:bool\\n     ( amount:decimal )\\n     \\" Enforce minimum precision allowed for transactions.\\"\\n     )\\n\\n   (defun create-account:string\\n     ( account:string\\n       guard:guard\\n     )\\n     \\" Create ACCOUNT with 0.0 balance, with GUARD controlling access.\\"\\n     )\\n\\n   (defun rotate:string\\n     ( account:string\\n       new-guard:guard\\n     )\\n     \\" Rotate guard for ACCOUNT. Transaction is validated against \\\\\\n     \\\\ existing guard before installing new guard. \\"\\n     )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface fungible-v1"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDI5NjE0Ng==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJPT0t2TlhnamZtY056SWxjSXhBV0tadXdFd2pMUzNWb2QtbWtobENSQ0JZIiwiQnVWLWZGSjRtMTAtWHYxMjZKcDlCaGtBenpCS3RBZFNjTU5PRjBQZDZxYyJd',
            hash: 'BuV-fFJ4m10-Xv126Jp9BhkAzzBKtAdScMNOF0Pd6qc',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(coin.coinbase \\"KAD_OPS_20\\" (read-keyset \\"kad-ops-20\\") 10.0)"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Write succeeded"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDI5NjE0NQ==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJPT0t2TlhnamZtY056SWxjSXhBV0tadXdFd2pMUzNWb2QtbWtobENSQ0JZIiwiRC1tY0VzMWJycE1OTloxTkx5a2haNEo5cFdFcHJYQmh1V2hDbWZFYUR0VSJd',
            hash: 'D-mcEs1brpMNNZ1NLykhZ4J9pWEprXBhuWhCmfEaDtU',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"\\n(define-keyset \'ns-admin-keyset (read-keyset \'ns-admin-keyset))\\n(define-keyset \'ns-operate-keyset (read-keyset \'ns-genesis-keyset))\\n\\n(module ns GOVERNANCE\\n  \\"Administers definition of new namespaces in Chainweb.\\"\\n\\n  (defschema reg-entry\\n    admin-guard:guard\\n    active:bool)\\n\\n  (deftable registry:{reg-entry})\\n\\n  (defcap GOVERNANCE ()\\n    (enforce-keyset \'ns-admin-keyset))\\n\\n  (defcap OPERATE ()\\n    (enforce-keyset \'ns-operate-keyset))\\n\\n  (defconst GUARD_SUCCESS (create-user-guard (success)))\\n  (defconst GUARD_FAILURE (create-user-guard (failure)))\\n\\n  (defun success ()\\n    true)\\n  (defun failure ()\\n    (enforce false \\"Disabled\\"))\\n\\n  (defun validate-name (name)\\n    (enforce (!= \\"\\" name) \\"Empty name not allowed\\")\\n    (enforce (< (length name) 64) \\"Name must be less than 64 characters long\\")\\n    (enforce (is-charset CHARSET_LATIN1 name)\\n             \\"Name must be in latin1 charset\\"))\\n\\n  (defun validate:bool\\n      ( ns-name:string\\n        ns-admin:guard\\n        )\\n    \\" Manages namespace install for Chainweb. Requires active row in registry \\\\\\n    \\\\ for NS-NAME with guard matching NS-ADMIN.\\"\\n\\n    (validate-name ns-name)\\n\\n    (with-default-read registry ns-name\\n      { \'admin-guard : ns-admin\\n      , \'active : false }\\n      { \'admin-guard := ag\\n      , \'active := is-active }\\n\\n        (enforce is-active \\"Inactive or unregistered namespace\\")\\n        (enforce (= ns-admin ag) \\"Admin guard must match guard in registry\\")\\n\\n        true))\\n\\n  (defun write-registry:string\\n      ( ns-name:string\\n        guard:guard\\n        active:bool\\n        )\\n    \\" Write entry with GUARD and ACTIVE into registry for NAME. \\\\\\n    \\\\ Guarded by operate keyset. \\"\\n\\n    (with-capability (OPERATE)\\n\\n      (validate-name ns-name)\\n\\n      (write registry ns-name\\n        { \'admin-guard: guard\\n        , \'active: active })\\n\\n      \\"Register entry written\\"))\\n\\n  (defun query:object{reg-entry}\\n      ( ns-name:string )\\n    (read registry ns-name))\\n\\n  )\\n\\n(create-table registry)\\n\\n(write-registry \\"kadena\\"\\n  (keyset-ref-guard \'ns-operate-keyset) true)\\n(write-registry \\"user\\" GUARD_FAILURE true)\\n(write-registry \\"free\\" GUARD_FAILURE true)\\n\\n(define-namespace \\"kadena\\"\\n  (keyset-ref-guard \'ns-operate-keyset)\\n  (keyset-ref-guard \'ns-operate-keyset))\\n\\n(define-namespace \\"user\\" GUARD_SUCCESS GUARD_FAILURE)\\n(define-namespace \\"free\\" GUARD_SUCCESS GUARD_FAILURE)\\n;;rotate to real operate keyset\\n(define-keyset \'ns-operate-keyset (read-keyset \'ns-operate-keyset))\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Keyset defined"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDI5NjE0NA==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJPT0t2TlhnamZtY056SWxjSXhBV0tadXdFd2pMUzNWb2QtbWtobENSQ0JZIiwiU0IzVzVFTGl6azl4elNWWk9MX3dsem5VNjh5aUhPQzlwWUhreHBVXzBnbyJd',
            hash: 'SB3W5ELizk9xzSVZOL_wlznU68yiHOC9pYHkxpU_0go',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface gas-payer-v1\\n\\n  (defcap GAS_PAYER:bool\\n    ( user:string\\n      limit:integer\\n      price:decimal\\n    )\\n    @doc\\n    \\" Provide a capability indicating that declaring module supports \\\\\\n    \\\\ gas payment for USER for gas LIMIT and PRICE. Functionality \\\\\\n    \\\\ should require capability (coin.FUND_TX), and should validate \\\\\\n    \\\\ the spend of (limit * price), possibly updating some database \\\\\\n    \\\\ entry. \\\\\\n    \\\\ Should compose capability required for \'create-gas-payer-guard\'.\\"\\n    @model\\n    [ (property (user != \\"\\"))\\n      (property (limit > 0))\\n      (property (price > 0.0))\\n    ]\\n  )\\n\\n  (defun create-gas-payer-guard:guard ()\\n    @doc\\n    \\" Provide a guard suitable for controlling a coin account that can \\\\\\n    \\\\ pay gas via GAS_PAYER mechanics. Generally this is accomplished \\\\\\n    \\\\ by having GAS_PAYER compose an unparameterized, unmanaged capability \\\\\\n    \\\\ that is required in this guard. Thus, if coin contract is able to \\\\\\n    \\\\ successfully acquire GAS_PAYER, the composed \'anonymous\' cap required \\\\\\n    \\\\ here will be in scope, and gas buy will succeed.\\"\\n  )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface gas-payer-v1"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDI5NjE0Mw==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJPT0t2TlhnamZtY056SWxjSXhBV0tadXdFd2pMUzNWb2QtbWtobENSQ0JZIiwieEpIYXlrdmFIMDlQWXpOcVNBTF9FWDlrNU40c2MybUMtdmU2TzlPSTQyWSJd',
            hash: 'xJHaykvaH09PYzNqSAL_EX9k5N4sc2mC-ve6O9OI42Y',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(module coin GOVERNANCE\\n\\n  @doc \\"\'coin\' represents the Kadena Coin Contract. This contract provides both the \\\\\\n  \\\\buy/redeem gas support in the form of \'fund-tx\', as well as transfer,       \\\\\\n  \\\\credit, debit, coinbase, account creation and query, as well as SPV burn    \\\\\\n  \\\\create. To access the coin contract, you may use its fully-qualified name,  \\\\\\n  \\\\or issue the \'(use coin)\' command in the body of a module declaration.\\"\\n\\n  @model\\n    [ (defproperty conserves-mass\\n        (= (column-delta coin-table \'balance) 0.0))\\n\\n      (defproperty valid-account (account:string)\\n        (and\\n          (>= (length account) 3)\\n          (<= (length account) 256)))\\n    ]\\n\\n  (implements fungible-v2)\\n\\n  ; --------------------------------------------------------------------------\\n  ; Schemas and Tables\\n\\n  (defschema coin-schema\\n    @doc \\"The coin contract token schema\\"\\n    @model [ (invariant (>= balance 0.0)) ]\\n\\n    balance:decimal\\n    guard:guard)\\n\\n  (deftable coin-table:{coin-schema})\\n\\n  ; --------------------------------------------------------------------------\\n  ; Capabilities\\n\\n  (defcap GOVERNANCE ()\\n    (enforce false \\"Enforce non-upgradeability\\"))\\n\\n  (defcap GAS ()\\n    \\"Magic capability to protect gas buy and redeem\\"\\n    true)\\n\\n  (defcap COINBASE ()\\n    \\"Magic capability to protect miner reward\\"\\n    true)\\n\\n  (defcap GENESIS ()\\n    \\"Magic capability constraining genesis transactions\\"\\n    true)\\n\\n  (defcap REMEDIATE ()\\n    \\"Magic capability for remediation transactions\\"\\n    true)\\n\\n  (defcap DEBIT (sender:string)\\n    \\"Capability for managing debiting operations\\"\\n    (enforce-guard (at \'guard (read coin-table sender)))\\n    (enforce (!= sender \\"\\") \\"valid sender\\"))\\n\\n  (defcap CREDIT (receiver:string)\\n    \\"Capability for managing crediting operations\\"\\n    (enforce (!= receiver \\"\\") \\"valid receiver\\"))\\n\\n  (defcap ROTATE (account:string)\\n    @doc \\"Autonomously managed capability for guard rotation\\"\\n    @managed\\n    true)\\n\\n  (defcap TRANSFER:bool\\n    ( sender:string\\n      receiver:string\\n      amount:decimal\\n    )\\n    @managed amount TRANSFER-mgr\\n    (enforce (!= sender receiver) \\"same sender and receiver\\")\\n    (enforce-unit amount)\\n    (enforce (> amount 0.0) \\"Positive amount\\")\\n    (compose-capability (DEBIT sender))\\n    (compose-capability (CREDIT receiver))\\n  )\\n\\n  (defun TRANSFER-mgr:decimal\\n    ( managed:decimal\\n      requested:decimal\\n    )\\n\\n    (let ((newbal (- managed requested)))\\n      (enforce (>= newbal 0.0)\\n        (format \\"TRANSFER exceeded for balance {}\\" [managed]))\\n      newbal)\\n  )\\n\\n  ; --------------------------------------------------------------------------\\n  ; Constants\\n\\n  (defconst COIN_CHARSET CHARSET_LATIN1\\n    \\"The default coin contract character set\\")\\n\\n  (defconst MINIMUM_PRECISION 12\\n    \\"Minimum allowed precision for coin transactions\\")\\n\\n  (defconst MINIMUM_ACCOUNT_LENGTH 3\\n    \\"Minimum account length admissible for coin accounts\\")\\n\\n  (defconst MAXIMUM_ACCOUNT_LENGTH 256\\n    \\"Maximum account name length admissible for coin accounts\\")\\n\\n  ; --------------------------------------------------------------------------\\n  ; Utilities\\n\\n  (defun enforce-unit:bool (amount:decimal)\\n    @doc \\"Enforce minimum precision allowed for coin transactions\\"\\n\\n    (enforce\\n      (= (floor amount MINIMUM_PRECISION)\\n         amount)\\n      (format \\"Amount violates minimum precision: {}\\" [amount]))\\n    )\\n\\n  (defun validate-account (account:string)\\n    @doc \\"Enforce that an account name conforms to the coin contract \\\\\\n         \\\\minimum and maximum length requirements, as well as the    \\\\\\n         \\\\latin-1 character set.\\"\\n\\n    (enforce\\n      (is-charset COIN_CHARSET account)\\n      (format\\n        \\"Account does not conform to the coin contract charset: {}\\"\\n        [account]))\\n\\n    (let ((account-length (length account)))\\n\\n      (enforce\\n        (>= account-length MINIMUM_ACCOUNT_LENGTH)\\n        (format\\n          \\"Account name does not conform to the min length requirement: {}\\"\\n          [account]))\\n\\n      (enforce\\n        (<= account-length MAXIMUM_ACCOUNT_LENGTH)\\n        (format\\n          \\"Account name does not conform to the max length requirement: {}\\"\\n          [account]))\\n      )\\n  )\\n\\n  ; --------------------------------------------------------------------------\\n  ; Coin Contract\\n\\n  (defun gas-only ()\\n    \\"Predicate for gas-only user guards.\\"\\n    (require-capability (GAS)))\\n\\n  (defun gas-guard (guard:guard)\\n    \\"Predicate for gas + single key user guards\\"\\n    (enforce-one\\n      \\"Enforce either the presence of a GAS cap or keyset\\"\\n      [ (gas-only)\\n        (enforce-guard guard)\\n      ]))\\n\\n  (defun buy-gas:string (sender:string total:decimal)\\n    @doc \\"This function describes the main \'gas buy\' operation. At this point \\\\\\n    \\\\MINER has been chosen from the pool, and will be validated. The SENDER   \\\\\\n    \\\\of this transaction has specified a gas limit LIMIT (maximum gas) for    \\\\\\n    \\\\the transaction, and the price is the spot price of gas at that time.    \\\\\\n    \\\\The gas buy will be executed prior to executing SENDER\'s code.\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n           ]\\n\\n    (validate-account sender)\\n\\n    (enforce-unit total)\\n    (enforce (> total 0.0) \\"gas supply must be a positive quantity\\")\\n\\n    (require-capability (GAS))\\n    (with-capability (DEBIT sender)\\n      (debit sender total))\\n    )\\n\\n  (defun redeem-gas:string (miner:string miner-guard:guard sender:string total:decimal)\\n    @doc \\"This function describes the main \'redeem gas\' operation. At this    \\\\\\n    \\\\point, the SENDER\'s transaction has been executed, and the gas that      \\\\\\n    \\\\was charged has been calculated. MINER will be credited the gas cost,    \\\\\\n    \\\\and SENDER will receive the remainder up to the limit\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account miner))\\n           ]\\n\\n    (validate-account sender)\\n    (validate-account miner)\\n    (enforce-unit total)\\n\\n    (require-capability (GAS))\\n    (let*\\n      ((fee (read-decimal \\"fee\\"))\\n       (refund (- total fee)))\\n\\n      (enforce-unit fee)\\n      (enforce (>= fee 0.0)\\n        \\"fee must be a non-negative quantity\\")\\n\\n      (enforce (>= refund 0.0)\\n        \\"refund must be a non-negative quantity\\")\\n\\n        ; directly update instead of credit\\n      (with-capability (CREDIT sender)\\n        (if (> refund 0.0)\\n          (with-read coin-table sender\\n            { \\"balance\\" := balance }\\n            (update coin-table sender\\n              { \\"balance\\": (+ balance refund) }))\\n\\n          \\"noop\\"))\\n\\n      (with-capability (CREDIT miner)\\n        (if (> fee 0.0)\\n          (credit miner miner-guard fee)\\n          \\"noop\\"))\\n      )\\n\\n    )\\n\\n  (defun create-account:string (account:string guard:guard)\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n\\n    (insert coin-table account\\n      { \\"balance\\" : 0.0\\n      , \\"guard\\"   : guard\\n      })\\n    )\\n\\n  (defun get-balance:decimal (account:string)\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n      balance\\n      )\\n    )\\n\\n  (defun details:object{fungible-v2.account-details}\\n    ( account:string )\\n    (with-read coin-table account\\n      { \\"balance\\" := bal\\n      , \\"guard\\" := g }\\n      { \\"account\\" : account\\n      , \\"balance\\" : bal\\n      , \\"guard\\": g })\\n    )\\n\\n  (defun rotate:string (account:string new-guard:guard)\\n    (with-capability (ROTATE account)\\n      (with-read coin-table account\\n        { \\"guard\\" := old-guard }\\n\\n        (enforce-guard old-guard)\\n\\n        (update coin-table account\\n          { \\"guard\\" : new-guard }\\n          )))\\n    )\\n\\n\\n  (defun precision:integer\\n    ()\\n    MINIMUM_PRECISION)\\n\\n  (defun transfer:string (sender:string receiver:string amount:decimal)\\n    @model [ (property conserves-mass)\\n             (property (> amount 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account receiver))\\n             (property (!= sender receiver)) ]\\n\\n    (enforce (!= sender receiver)\\n      \\"sender cannot be the receiver of a transfer\\")\\n\\n    (validate-account sender)\\n    (validate-account receiver)\\n\\n    (enforce (> amount 0.0)\\n      \\"transfer amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (with-capability (TRANSFER sender receiver amount)\\n      (debit sender amount)\\n      (with-read coin-table receiver\\n        { \\"guard\\" := g }\\n\\n        (credit receiver g amount))\\n      )\\n    )\\n\\n  (defun transfer-create:string\\n    ( sender:string\\n      receiver:string\\n      receiver-guard:guard\\n      amount:decimal )\\n\\n    @model [ (property conserves-mass) ]\\n\\n    (enforce (!= sender receiver)\\n      \\"sender cannot be the receiver of a transfer\\")\\n\\n    (validate-account sender)\\n    (validate-account receiver)\\n\\n    (enforce (> amount 0.0)\\n      \\"transfer amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (with-capability (TRANSFER sender receiver amount)\\n      (debit sender amount)\\n      (credit receiver receiver-guard amount))\\n    )\\n\\n  (defun coinbase:string (account:string account-guard:guard amount:decimal)\\n    @doc \\"Internal function for the initial creation of coins.  This function \\\\\\n    \\\\cannot be used outside of the coin contract.\\"\\n\\n    @model [ (property (valid-account account))\\n             (property (> amount 0.0))\\n           ]\\n\\n    (validate-account account)\\n    (enforce-unit amount)\\n\\n    (require-capability (COINBASE))\\n    (with-capability (CREDIT account)\\n      (credit account account-guard amount))\\n    )\\n\\n  (defun remediate:string (account:string amount:decimal)\\n    @doc \\"Allows for remediation transactions. This function \\\\\\n         \\\\is protected by the REMEDIATE capability\\"\\n    @model [ (property (valid-account account))\\n             (property (> amount 0.0))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0)\\n      \\"Remediation amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (require-capability (REMEDIATE))\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n\\n      (enforce (<= amount balance) \\"Insufficient funds\\")\\n\\n      (update coin-table account\\n        { \\"balance\\" : (- balance amount) }\\n        ))\\n    )\\n\\n  (defpact fund-tx (sender:string miner:string miner-guard:guard total:decimal)\\n    @doc \\"\'fund-tx\' is a special pact to fund a transaction in two steps,     \\\\\\n    \\\\with the actual transaction transpiring in the middle:                   \\\\\\n    \\\\                                                                         \\\\\\n    \\\\  1) A buying phase, debiting the sender for total gas and fee, yielding \\\\\\n    \\\\     TX_MAX_CHARGE.                                                      \\\\\\n    \\\\  2) A settlement phase, resuming TX_MAX_CHARGE, and allocating to the   \\\\\\n    \\\\     coinbase account for used gas and fee, and sender account for bal-  \\\\\\n    \\\\     ance (unused gas, if any).\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account miner))\\n             ;(property conserves-mass) not supported yet\\n           ]\\n\\n    (step (buy-gas sender total))\\n    (step (redeem-gas miner miner-guard sender total))\\n    )\\n\\n  (defun debit:string (account:string amount:decimal)\\n    @doc \\"Debit AMOUNT from ACCOUNT balance\\"\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account account))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0)\\n      \\"debit amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (require-capability (DEBIT account))\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n\\n      (enforce (<= amount balance) \\"Insufficient funds\\")\\n\\n      (update coin-table account\\n        { \\"balance\\" : (- balance amount) }\\n        ))\\n    )\\n\\n\\n  (defun credit:string (account:string guard:guard amount:decimal)\\n    @doc \\"Credit AMOUNT to ACCOUNT balance\\"\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account account))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0) \\"credit amount must be positive\\")\\n    (enforce-unit amount)\\n\\n    (require-capability (CREDIT account))\\n    (with-default-read coin-table account\\n      { \\"balance\\" : 0.0, \\"guard\\" : guard }\\n      { \\"balance\\" := balance, \\"guard\\" := retg }\\n      ; we don\'t want to overwrite an existing guard with the user-supplied one\\n      (enforce (= retg guard)\\n        \\"account guards do not match\\")\\n\\n      (write coin-table account\\n        { \\"balance\\" : (+ balance amount)\\n        , \\"guard\\"   : retg\\n        })\\n      ))\\n\\n\\n  (defschema crosschain-schema\\n    @doc \\"Schema for yielded value in cross-chain transfers\\"\\n    receiver:string\\n    receiver-guard:guard\\n    amount:decimal)\\n\\n  (defpact transfer-crosschain:string\\n    ( sender:string\\n      receiver:string\\n      receiver-guard:guard\\n      target-chain:string\\n      amount:decimal )\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account receiver))\\n           ]\\n\\n    (step\\n      (with-capability (DEBIT sender)\\n\\n        (validate-account sender)\\n        (validate-account receiver)\\n\\n        (enforce (!= \\"\\" target-chain) \\"empty target-chain\\")\\n        (enforce (!= (at \'chain-id (chain-data)) target-chain)\\n          \\"cannot run cross-chain transfers to the same chain\\")\\n\\n        (enforce (> amount 0.0)\\n          \\"transfer quantity must be positive\\")\\n\\n        (enforce-unit amount)\\n\\n        ;; step 1 - debit delete-account on current chain\\n        (debit sender amount)\\n\\n        (let\\n          ((crosschain-details:object{crosschain-schema}\\n            { \\"receiver\\" : receiver\\n            , \\"receiver-guard\\" : receiver-guard\\n            , \\"amount\\" : amount\\n            }))\\n          (yield crosschain-details target-chain)\\n          )))\\n\\n    (step\\n      (resume\\n        { \\"receiver\\" := receiver\\n        , \\"receiver-guard\\" := receiver-guard\\n        , \\"amount\\" := amount\\n        }\\n\\n        ;; step 2 - credit create account on target chain\\n        (with-capability (CREDIT receiver)\\n          (credit receiver receiver-guard amount))\\n        ))\\n    )\\n\\n\\n  ; --------------------------------------------------------------------------\\n  ; Coin allocations\\n\\n  (defschema allocation-schema\\n    @doc \\"Genesis allocation registry\\"\\n    ;@model [ (invariant (>= balance 0.0)) ]\\n\\n    balance:decimal\\n    date:time\\n    guard:guard\\n    redeemed:bool)\\n\\n  (deftable allocation-table:{allocation-schema})\\n\\n  (defun create-allocation-account\\n    ( account:string\\n      date:time\\n      keyset-ref:string\\n      amount:decimal\\n    )\\n\\n    @doc \\"Add an entry to the coin allocation table. This function \\\\\\n         \\\\also creates a corresponding empty coin contract account \\\\\\n         \\\\of the same name and guard. Requires GENESIS capability. \\"\\n\\n    @model [ (property (valid-account account)) ]\\n\\n    (require-capability (GENESIS))\\n\\n    (validate-account account)\\n    (enforce (>= amount 0.0)\\n      \\"allocation amount must be non-negative\\")\\n\\n    (enforce-unit amount)\\n\\n    (let\\n      ((guard:guard (keyset-ref-guard keyset-ref)))\\n\\n      (create-account account guard)\\n\\n      (insert allocation-table account\\n        { \\"balance\\" : amount\\n        , \\"date\\" : date\\n        , \\"guard\\" : guard\\n        , \\"redeemed\\" : false\\n        })))\\n\\n  (defun release-allocation\\n    ( account:string )\\n\\n    @doc \\"Release funds associated with allocation ACCOUNT into main ledger.   \\\\\\n         \\\\ACCOUNT must already exist in main ledger. Allocation is deactivated \\\\\\n         \\\\after release.\\"\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n\\n    (with-read allocation-table account\\n      { \\"balance\\" := balance\\n      , \\"date\\" := release-time\\n      , \\"redeemed\\" := redeemed\\n      , \\"guard\\" := guard\\n      }\\n\\n      (let ((curr-time:time (at \'block-time (chain-data))))\\n\\n        (enforce (not redeemed)\\n          \\"allocation funds have already been redeemed\\")\\n\\n        (enforce\\n          (>= curr-time release-time)\\n          (format \\"funds locked until {}. current time: {}\\" [release-time curr-time]))\\n\\n        (enforce-guard guard)\\n\\n        (with-capability (CREDIT account)\\n          (credit account guard balance)\\n\\n          (update allocation-table account\\n            { \\"redeemed\\" : true\\n            , \\"balance\\" : 0.0\\n            })\\n\\n          \\"Allocation successfully released to main ledger\\")\\n    )))\\n\\n)\\n(create-table coin-table)\\n(create-table allocation-table)\\n(enforce\\n  (=\\n    \\"ut_J_ZNkoyaPUEJhiwVeWnkSQn9JT9sQCWKdjjVVrWo\\"\\n    (at \'hash (describe-module \'coin)))\\n  \\"hash mismatch\\")\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: 'true',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDI5NjE0Mg==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJPT0t2TlhnamZtY056SWxjSXhBV0tadXdFd2pMUzNWb2QtbWtobENSQ0JZIiwiMDVCdGo3ZUJaQlc3by1TYUxvVmhBaWNNVVBaVUJiRzZRVDhfTEFrQ3hIcyJd',
            hash: '05Btj7eBZBW7o-SaLoVhAicMUPZUBbG6QT8_LAkCxHs',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface fungible-v2\\n\\n  \\" Standard for fungible coins and tokens as specified in KIP-0002. \\"\\n\\n   ; ----------------------------------------------------------------------\\n   ; Schema\\n\\n   (defschema account-details\\n    @doc \\"Schema for results of \'account\' operation.\\"\\n    @model [ (invariant (!= \\"\\" sender)) ]\\n\\n    account:string\\n    balance:decimal\\n    guard:guard)\\n\\n\\n   ; ----------------------------------------------------------------------\\n   ; Caps\\n\\n   (defcap TRANSFER:bool\\n     ( sender:string\\n       receiver:string\\n       amount:decimal\\n     )\\n     @doc \\" Managed capability sealing AMOUNT for transfer from SENDER to \\\\\\n          \\\\ RECEIVER. Permits any number of transfers up to AMOUNT.\\"\\n     @managed amount TRANSFER-mgr\\n     )\\n\\n   (defun TRANSFER-mgr:decimal\\n     ( managed:decimal\\n       requested:decimal\\n     )\\n     @doc \\" Manages TRANSFER AMOUNT linearly, \\\\\\n          \\\\ such that a request for 1.0 amount on a 3.0 \\\\\\n          \\\\ managed quantity emits updated amount 2.0.\\"\\n     )\\n\\n   ; ----------------------------------------------------------------------\\n   ; Functionality\\n\\n\\n  (defun transfer:string\\n    ( sender:string\\n      receiver:string\\n      amount:decimal\\n    )\\n    @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n         \\\\ Fails if either SENDER or RECEIVER does not exist.\\"\\n    @model [ (property (> amount 0.0))\\n             (property (!= sender \\"\\"))\\n             (property (!= receiver \\"\\"))\\n             (property (!= sender receiver))\\n           ]\\n    )\\n\\n   (defun transfer-create:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       amount:decimal\\n     )\\n     @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n          \\\\ Fails if SENDER does not exist. If RECEIVER exists, guard \\\\\\n          \\\\ must match existing value. If RECEIVER does not exist, \\\\\\n          \\\\ RECEIVER account is created using RECEIVER-GUARD. \\\\\\n          \\\\ Subject to management by TRANSFER capability.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n            ]\\n     )\\n\\n   (defpact transfer-crosschain:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       target-chain:string\\n       amount:decimal\\n     )\\n     @doc \\" 2-step pact to transfer AMOUNT from SENDER on current chain \\\\\\n          \\\\ to RECEIVER on TARGET-CHAIN via SPV proof. \\\\\\n          \\\\ TARGET-CHAIN must be different than current chain id. \\\\\\n          \\\\ First step debits AMOUNT coins in SENDER account and yields \\\\\\n          \\\\ RECEIVER, RECEIVER_GUARD and AMOUNT to TARGET-CHAIN. \\\\\\n          \\\\ Second step continuation is sent into TARGET-CHAIN with proof \\\\\\n          \\\\ obtained from the spv \'output\' endpoint of Chainweb. \\\\\\n          \\\\ Proof is validated and RECEIVER is credited with AMOUNT \\\\\\n          \\\\ creating account with RECEIVER_GUARD as necessary.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n              (property (!= target-chain \\"\\"))\\n            ]\\n     )\\n\\n   (defun get-balance:decimal\\n     ( account:string )\\n     \\" Get balance for ACCOUNT. Fails if account does not exist.\\"\\n     )\\n\\n   (defun details:object{account-details}\\n     ( account: string )\\n     \\" Get an object with details of ACCOUNT. \\\\\\n     \\\\ Fails if account does not exist.\\"\\n     )\\n\\n   (defun precision:integer\\n     ()\\n     \\"Return the maximum allowed decimal precision.\\"\\n     )\\n\\n   (defun enforce-unit:bool\\n     ( amount:decimal )\\n     \\" Enforce minimum precision allowed for transactions.\\"\\n     )\\n\\n   (defun create-account:string\\n     ( account:string\\n       guard:guard\\n     )\\n     \\" Create ACCOUNT with 0.0 balance, with GUARD controlling access.\\"\\n     )\\n\\n   (defun rotate:string\\n     ( account:string\\n       new-guard:guard\\n     )\\n     \\" Rotate guard for ACCOUNT. Transaction is validated against \\\\\\n     \\\\ existing guard before installing new guard. \\"\\n     )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface fungible-v2"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDI5NjE0MQ==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJPT0t2TlhnamZtY056SWxjSXhBV0tadXdFd2pMUzNWb2QtbWtobENSQ0JZIiwiNDhUMExqQW5TRnBGV3h2dmFQVi1fNkUtQ2pEQVBoV1lVRldidnlmMmxGcyJd',
            hash: '48T0LjAnSFpFWxvvaPV-_6E-CjDAPhWYUFWbvyf2lFs',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface fungible-v1\\n\\n  \\" Standard for fungible coins and tokens as specified in KIP-0002. \\"\\n\\n   ; ----------------------------------------------------------------------\\n   ; Schema\\n\\n   (defschema account-details\\n    @doc \\"Schema for results of \'account\' operation.\\"\\n    @model [ (invariant (!= \\"\\" sender)) ]\\n\\n    account:string\\n    balance:decimal\\n    guard:guard)\\n\\n\\n   ; ----------------------------------------------------------------------\\n   ; Caps\\n\\n   (defcap TRANSFER:bool\\n     ( sender:string\\n       receiver:string\\n       amount:decimal\\n     )\\n     @doc \\" Managed capability sealing AMOUNT for transfer from SENDER to \\\\\\n          \\\\ RECEIVER. Permits any number of transfers up to AMOUNT.\\"\\n     @managed amount TRANSFER-mgr\\n     )\\n\\n   (defun TRANSFER-mgr:decimal\\n     ( managed:decimal\\n       requested:decimal\\n     )\\n     @doc \\" Manages TRANSFER AMOUNT linearly, \\\\\\n          \\\\ such that a request for 1.0 amount on a 3.0 \\\\\\n          \\\\ managed quantity emits updated amount 2.0.\\"\\n     )\\n\\n   ; ----------------------------------------------------------------------\\n   ; Functionality\\n\\n   (defun transfer-create:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       amount:decimal\\n     )\\n     @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n          \\\\ Fails if SENDER does not exist. If RECEIVER exists, guard \\\\\\n          \\\\ must match existing value. If RECEIVER does not exist, \\\\\\n          \\\\ RECEIVER account is created using RECEIVER-GUARD. \\\\\\n          \\\\ Subject to management by TRANSFER capability.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n            ]\\n     )\\n\\n   (defpact transfer-crosschain:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       target-chain:string\\n       amount:decimal\\n     )\\n     @doc \\" 2-step pact to transfer AMOUNT from SENDER on current chain \\\\\\n          \\\\ to RECEIVER on TARGET-CHAIN via SPV proof. \\\\\\n          \\\\ TARGET-CHAIN must be different than current chain id. \\\\\\n          \\\\ First step debits AMOUNT coins in SENDER account and yields \\\\\\n          \\\\ RECEIVER, RECEIVER_GUARD and AMOUNT to TARGET-CHAIN. \\\\\\n          \\\\ Second step continuation is sent into TARGET-CHAIN with proof \\\\\\n          \\\\ obtained from the spv \'output\' endpoint of Chainweb. \\\\\\n          \\\\ Proof is validated and RECEIVER is credited with AMOUNT \\\\\\n          \\\\ creating account with RECEIVER_GUARD as necessary.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n              (property (!= target-chain \\"\\"))\\n            ]\\n     )\\n\\n   (defun get-balance:decimal\\n     ( account:string )\\n     \\" Get balance for ACCOUNT. Fails if account does not exist.\\"\\n     )\\n\\n   (defun details:object{account-details}\\n     ( account: string )\\n     \\" Get an object with details of ACCOUNT. \\\\\\n     \\\\ Fails if account does not exist.\\"\\n     )\\n\\n   (defun precision:integer\\n     ()\\n     \\"Return the maximum allowed decimal precision.\\"\\n     )\\n\\n   (defun enforce-unit:bool\\n     ( amount:decimal )\\n     \\" Enforce minimum precision allowed for transactions.\\"\\n     )\\n\\n   (defun create-account:string\\n     ( account:string\\n       guard:guard\\n     )\\n     \\" Create ACCOUNT with 0.0 balance, with GUARD controlling access.\\"\\n     )\\n\\n   (defun rotate:string\\n     ( account:string\\n       new-guard:guard\\n     )\\n     \\" Rotate guard for ACCOUNT. Transaction is validated against \\\\\\n     \\\\ existing guard before installing new guard. \\"\\n     )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface fungible-v1"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDIxMTk4MA==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJueFNTdDdXU2ZVYXhRTW1ZSWpkYW9VLUVnVUh4WVV0RjQ0OVQzSzJfSXcwIiwiQnVWLWZGSjRtMTAtWHYxMjZKcDlCaGtBenpCS3RBZFNjTU5PRjBQZDZxYyJd',
            hash: 'BuV-fFJ4m10-Xv126Jp9BhkAzzBKtAdScMNOF0Pd6qc',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(coin.coinbase \\"KAD_OPS_20\\" (read-keyset \\"kad-ops-20\\") 10.0)"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Write succeeded"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDIxMTk3OQ==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJueFNTdDdXU2ZVYXhRTW1ZSWpkYW9VLUVnVUh4WVV0RjQ0OVQzSzJfSXcwIiwiRC1tY0VzMWJycE1OTloxTkx5a2haNEo5cFdFcHJYQmh1V2hDbWZFYUR0VSJd',
            hash: 'D-mcEs1brpMNNZ1NLykhZ4J9pWEprXBhuWhCmfEaDtU',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"\\n(define-keyset \'ns-admin-keyset (read-keyset \'ns-admin-keyset))\\n(define-keyset \'ns-operate-keyset (read-keyset \'ns-genesis-keyset))\\n\\n(module ns GOVERNANCE\\n  \\"Administers definition of new namespaces in Chainweb.\\"\\n\\n  (defschema reg-entry\\n    admin-guard:guard\\n    active:bool)\\n\\n  (deftable registry:{reg-entry})\\n\\n  (defcap GOVERNANCE ()\\n    (enforce-keyset \'ns-admin-keyset))\\n\\n  (defcap OPERATE ()\\n    (enforce-keyset \'ns-operate-keyset))\\n\\n  (defconst GUARD_SUCCESS (create-user-guard (success)))\\n  (defconst GUARD_FAILURE (create-user-guard (failure)))\\n\\n  (defun success ()\\n    true)\\n  (defun failure ()\\n    (enforce false \\"Disabled\\"))\\n\\n  (defun validate-name (name)\\n    (enforce (!= \\"\\" name) \\"Empty name not allowed\\")\\n    (enforce (< (length name) 64) \\"Name must be less than 64 characters long\\")\\n    (enforce (is-charset CHARSET_LATIN1 name)\\n             \\"Name must be in latin1 charset\\"))\\n\\n  (defun validate:bool\\n      ( ns-name:string\\n        ns-admin:guard\\n        )\\n    \\" Manages namespace install for Chainweb. Requires active row in registry \\\\\\n    \\\\ for NS-NAME with guard matching NS-ADMIN.\\"\\n\\n    (validate-name ns-name)\\n\\n    (with-default-read registry ns-name\\n      { \'admin-guard : ns-admin\\n      , \'active : false }\\n      { \'admin-guard := ag\\n      , \'active := is-active }\\n\\n        (enforce is-active \\"Inactive or unregistered namespace\\")\\n        (enforce (= ns-admin ag) \\"Admin guard must match guard in registry\\")\\n\\n        true))\\n\\n  (defun write-registry:string\\n      ( ns-name:string\\n        guard:guard\\n        active:bool\\n        )\\n    \\" Write entry with GUARD and ACTIVE into registry for NAME. \\\\\\n    \\\\ Guarded by operate keyset. \\"\\n\\n    (with-capability (OPERATE)\\n\\n      (validate-name ns-name)\\n\\n      (write registry ns-name\\n        { \'admin-guard: guard\\n        , \'active: active })\\n\\n      \\"Register entry written\\"))\\n\\n  (defun query:object{reg-entry}\\n      ( ns-name:string )\\n    (read registry ns-name))\\n\\n  )\\n\\n(create-table registry)\\n\\n(write-registry \\"kadena\\"\\n  (keyset-ref-guard \'ns-operate-keyset) true)\\n(write-registry \\"user\\" GUARD_FAILURE true)\\n(write-registry \\"free\\" GUARD_FAILURE true)\\n\\n(define-namespace \\"kadena\\"\\n  (keyset-ref-guard \'ns-operate-keyset)\\n  (keyset-ref-guard \'ns-operate-keyset))\\n\\n(define-namespace \\"user\\" GUARD_SUCCESS GUARD_FAILURE)\\n(define-namespace \\"free\\" GUARD_SUCCESS GUARD_FAILURE)\\n;;rotate to real operate keyset\\n(define-keyset \'ns-operate-keyset (read-keyset \'ns-operate-keyset))\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Keyset defined"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDIxMTk3OA==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJueFNTdDdXU2ZVYXhRTW1ZSWpkYW9VLUVnVUh4WVV0RjQ0OVQzSzJfSXcwIiwiU0IzVzVFTGl6azl4elNWWk9MX3dsem5VNjh5aUhPQzlwWUhreHBVXzBnbyJd',
            hash: 'SB3W5ELizk9xzSVZOL_wlznU68yiHOC9pYHkxpU_0go',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface gas-payer-v1\\n\\n  (defcap GAS_PAYER:bool\\n    ( user:string\\n      limit:integer\\n      price:decimal\\n    )\\n    @doc\\n    \\" Provide a capability indicating that declaring module supports \\\\\\n    \\\\ gas payment for USER for gas LIMIT and PRICE. Functionality \\\\\\n    \\\\ should require capability (coin.FUND_TX), and should validate \\\\\\n    \\\\ the spend of (limit * price), possibly updating some database \\\\\\n    \\\\ entry. \\\\\\n    \\\\ Should compose capability required for \'create-gas-payer-guard\'.\\"\\n    @model\\n    [ (property (user != \\"\\"))\\n      (property (limit > 0))\\n      (property (price > 0.0))\\n    ]\\n  )\\n\\n  (defun create-gas-payer-guard:guard ()\\n    @doc\\n    \\" Provide a guard suitable for controlling a coin account that can \\\\\\n    \\\\ pay gas via GAS_PAYER mechanics. Generally this is accomplished \\\\\\n    \\\\ by having GAS_PAYER compose an unparameterized, unmanaged capability \\\\\\n    \\\\ that is required in this guard. Thus, if coin contract is able to \\\\\\n    \\\\ successfully acquire GAS_PAYER, the composed \'anonymous\' cap required \\\\\\n    \\\\ here will be in scope, and gas buy will succeed.\\"\\n  )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface gas-payer-v1"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDIxMTk3Nw==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJueFNTdDdXU2ZVYXhRTW1ZSWpkYW9VLUVnVUh4WVV0RjQ0OVQzSzJfSXcwIiwieEpIYXlrdmFIMDlQWXpOcVNBTF9FWDlrNU40c2MybUMtdmU2TzlPSTQyWSJd',
            hash: 'xJHaykvaH09PYzNqSAL_EX9k5N4sc2mC-ve6O9OI42Y',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(module coin GOVERNANCE\\n\\n  @doc \\"\'coin\' represents the Kadena Coin Contract. This contract provides both the \\\\\\n  \\\\buy/redeem gas support in the form of \'fund-tx\', as well as transfer,       \\\\\\n  \\\\credit, debit, coinbase, account creation and query, as well as SPV burn    \\\\\\n  \\\\create. To access the coin contract, you may use its fully-qualified name,  \\\\\\n  \\\\or issue the \'(use coin)\' command in the body of a module declaration.\\"\\n\\n  @model\\n    [ (defproperty conserves-mass\\n        (= (column-delta coin-table \'balance) 0.0))\\n\\n      (defproperty valid-account (account:string)\\n        (and\\n          (>= (length account) 3)\\n          (<= (length account) 256)))\\n    ]\\n\\n  (implements fungible-v2)\\n\\n  ; --------------------------------------------------------------------------\\n  ; Schemas and Tables\\n\\n  (defschema coin-schema\\n    @doc \\"The coin contract token schema\\"\\n    @model [ (invariant (>= balance 0.0)) ]\\n\\n    balance:decimal\\n    guard:guard)\\n\\n  (deftable coin-table:{coin-schema})\\n\\n  ; --------------------------------------------------------------------------\\n  ; Capabilities\\n\\n  (defcap GOVERNANCE ()\\n    (enforce false \\"Enforce non-upgradeability\\"))\\n\\n  (defcap GAS ()\\n    \\"Magic capability to protect gas buy and redeem\\"\\n    true)\\n\\n  (defcap COINBASE ()\\n    \\"Magic capability to protect miner reward\\"\\n    true)\\n\\n  (defcap GENESIS ()\\n    \\"Magic capability constraining genesis transactions\\"\\n    true)\\n\\n  (defcap REMEDIATE ()\\n    \\"Magic capability for remediation transactions\\"\\n    true)\\n\\n  (defcap DEBIT (sender:string)\\n    \\"Capability for managing debiting operations\\"\\n    (enforce-guard (at \'guard (read coin-table sender)))\\n    (enforce (!= sender \\"\\") \\"valid sender\\"))\\n\\n  (defcap CREDIT (receiver:string)\\n    \\"Capability for managing crediting operations\\"\\n    (enforce (!= receiver \\"\\") \\"valid receiver\\"))\\n\\n  (defcap ROTATE (account:string)\\n    @doc \\"Autonomously managed capability for guard rotation\\"\\n    @managed\\n    true)\\n\\n  (defcap TRANSFER:bool\\n    ( sender:string\\n      receiver:string\\n      amount:decimal\\n    )\\n    @managed amount TRANSFER-mgr\\n    (enforce (!= sender receiver) \\"same sender and receiver\\")\\n    (enforce-unit amount)\\n    (enforce (> amount 0.0) \\"Positive amount\\")\\n    (compose-capability (DEBIT sender))\\n    (compose-capability (CREDIT receiver))\\n  )\\n\\n  (defun TRANSFER-mgr:decimal\\n    ( managed:decimal\\n      requested:decimal\\n    )\\n\\n    (let ((newbal (- managed requested)))\\n      (enforce (>= newbal 0.0)\\n        (format \\"TRANSFER exceeded for balance {}\\" [managed]))\\n      newbal)\\n  )\\n\\n  ; --------------------------------------------------------------------------\\n  ; Constants\\n\\n  (defconst COIN_CHARSET CHARSET_LATIN1\\n    \\"The default coin contract character set\\")\\n\\n  (defconst MINIMUM_PRECISION 12\\n    \\"Minimum allowed precision for coin transactions\\")\\n\\n  (defconst MINIMUM_ACCOUNT_LENGTH 3\\n    \\"Minimum account length admissible for coin accounts\\")\\n\\n  (defconst MAXIMUM_ACCOUNT_LENGTH 256\\n    \\"Maximum account name length admissible for coin accounts\\")\\n\\n  ; --------------------------------------------------------------------------\\n  ; Utilities\\n\\n  (defun enforce-unit:bool (amount:decimal)\\n    @doc \\"Enforce minimum precision allowed for coin transactions\\"\\n\\n    (enforce\\n      (= (floor amount MINIMUM_PRECISION)\\n         amount)\\n      (format \\"Amount violates minimum precision: {}\\" [amount]))\\n    )\\n\\n  (defun validate-account (account:string)\\n    @doc \\"Enforce that an account name conforms to the coin contract \\\\\\n         \\\\minimum and maximum length requirements, as well as the    \\\\\\n         \\\\latin-1 character set.\\"\\n\\n    (enforce\\n      (is-charset COIN_CHARSET account)\\n      (format\\n        \\"Account does not conform to the coin contract charset: {}\\"\\n        [account]))\\n\\n    (let ((account-length (length account)))\\n\\n      (enforce\\n        (>= account-length MINIMUM_ACCOUNT_LENGTH)\\n        (format\\n          \\"Account name does not conform to the min length requirement: {}\\"\\n          [account]))\\n\\n      (enforce\\n        (<= account-length MAXIMUM_ACCOUNT_LENGTH)\\n        (format\\n          \\"Account name does not conform to the max length requirement: {}\\"\\n          [account]))\\n      )\\n  )\\n\\n  ; --------------------------------------------------------------------------\\n  ; Coin Contract\\n\\n  (defun gas-only ()\\n    \\"Predicate for gas-only user guards.\\"\\n    (require-capability (GAS)))\\n\\n  (defun gas-guard (guard:guard)\\n    \\"Predicate for gas + single key user guards\\"\\n    (enforce-one\\n      \\"Enforce either the presence of a GAS cap or keyset\\"\\n      [ (gas-only)\\n        (enforce-guard guard)\\n      ]))\\n\\n  (defun buy-gas:string (sender:string total:decimal)\\n    @doc \\"This function describes the main \'gas buy\' operation. At this point \\\\\\n    \\\\MINER has been chosen from the pool, and will be validated. The SENDER   \\\\\\n    \\\\of this transaction has specified a gas limit LIMIT (maximum gas) for    \\\\\\n    \\\\the transaction, and the price is the spot price of gas at that time.    \\\\\\n    \\\\The gas buy will be executed prior to executing SENDER\'s code.\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n           ]\\n\\n    (validate-account sender)\\n\\n    (enforce-unit total)\\n    (enforce (> total 0.0) \\"gas supply must be a positive quantity\\")\\n\\n    (require-capability (GAS))\\n    (with-capability (DEBIT sender)\\n      (debit sender total))\\n    )\\n\\n  (defun redeem-gas:string (miner:string miner-guard:guard sender:string total:decimal)\\n    @doc \\"This function describes the main \'redeem gas\' operation. At this    \\\\\\n    \\\\point, the SENDER\'s transaction has been executed, and the gas that      \\\\\\n    \\\\was charged has been calculated. MINER will be credited the gas cost,    \\\\\\n    \\\\and SENDER will receive the remainder up to the limit\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account miner))\\n           ]\\n\\n    (validate-account sender)\\n    (validate-account miner)\\n    (enforce-unit total)\\n\\n    (require-capability (GAS))\\n    (let*\\n      ((fee (read-decimal \\"fee\\"))\\n       (refund (- total fee)))\\n\\n      (enforce-unit fee)\\n      (enforce (>= fee 0.0)\\n        \\"fee must be a non-negative quantity\\")\\n\\n      (enforce (>= refund 0.0)\\n        \\"refund must be a non-negative quantity\\")\\n\\n        ; directly update instead of credit\\n      (with-capability (CREDIT sender)\\n        (if (> refund 0.0)\\n          (with-read coin-table sender\\n            { \\"balance\\" := balance }\\n            (update coin-table sender\\n              { \\"balance\\": (+ balance refund) }))\\n\\n          \\"noop\\"))\\n\\n      (with-capability (CREDIT miner)\\n        (if (> fee 0.0)\\n          (credit miner miner-guard fee)\\n          \\"noop\\"))\\n      )\\n\\n    )\\n\\n  (defun create-account:string (account:string guard:guard)\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n\\n    (insert coin-table account\\n      { \\"balance\\" : 0.0\\n      , \\"guard\\"   : guard\\n      })\\n    )\\n\\n  (defun get-balance:decimal (account:string)\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n      balance\\n      )\\n    )\\n\\n  (defun details:object{fungible-v2.account-details}\\n    ( account:string )\\n    (with-read coin-table account\\n      { \\"balance\\" := bal\\n      , \\"guard\\" := g }\\n      { \\"account\\" : account\\n      , \\"balance\\" : bal\\n      , \\"guard\\": g })\\n    )\\n\\n  (defun rotate:string (account:string new-guard:guard)\\n    (with-capability (ROTATE account)\\n      (with-read coin-table account\\n        { \\"guard\\" := old-guard }\\n\\n        (enforce-guard old-guard)\\n\\n        (update coin-table account\\n          { \\"guard\\" : new-guard }\\n          )))\\n    )\\n\\n\\n  (defun precision:integer\\n    ()\\n    MINIMUM_PRECISION)\\n\\n  (defun transfer:string (sender:string receiver:string amount:decimal)\\n    @model [ (property conserves-mass)\\n             (property (> amount 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account receiver))\\n             (property (!= sender receiver)) ]\\n\\n    (enforce (!= sender receiver)\\n      \\"sender cannot be the receiver of a transfer\\")\\n\\n    (validate-account sender)\\n    (validate-account receiver)\\n\\n    (enforce (> amount 0.0)\\n      \\"transfer amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (with-capability (TRANSFER sender receiver amount)\\n      (debit sender amount)\\n      (with-read coin-table receiver\\n        { \\"guard\\" := g }\\n\\n        (credit receiver g amount))\\n      )\\n    )\\n\\n  (defun transfer-create:string\\n    ( sender:string\\n      receiver:string\\n      receiver-guard:guard\\n      amount:decimal )\\n\\n    @model [ (property conserves-mass) ]\\n\\n    (enforce (!= sender receiver)\\n      \\"sender cannot be the receiver of a transfer\\")\\n\\n    (validate-account sender)\\n    (validate-account receiver)\\n\\n    (enforce (> amount 0.0)\\n      \\"transfer amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (with-capability (TRANSFER sender receiver amount)\\n      (debit sender amount)\\n      (credit receiver receiver-guard amount))\\n    )\\n\\n  (defun coinbase:string (account:string account-guard:guard amount:decimal)\\n    @doc \\"Internal function for the initial creation of coins.  This function \\\\\\n    \\\\cannot be used outside of the coin contract.\\"\\n\\n    @model [ (property (valid-account account))\\n             (property (> amount 0.0))\\n           ]\\n\\n    (validate-account account)\\n    (enforce-unit amount)\\n\\n    (require-capability (COINBASE))\\n    (with-capability (CREDIT account)\\n      (credit account account-guard amount))\\n    )\\n\\n  (defun remediate:string (account:string amount:decimal)\\n    @doc \\"Allows for remediation transactions. This function \\\\\\n         \\\\is protected by the REMEDIATE capability\\"\\n    @model [ (property (valid-account account))\\n             (property (> amount 0.0))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0)\\n      \\"Remediation amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (require-capability (REMEDIATE))\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n\\n      (enforce (<= amount balance) \\"Insufficient funds\\")\\n\\n      (update coin-table account\\n        { \\"balance\\" : (- balance amount) }\\n        ))\\n    )\\n\\n  (defpact fund-tx (sender:string miner:string miner-guard:guard total:decimal)\\n    @doc \\"\'fund-tx\' is a special pact to fund a transaction in two steps,     \\\\\\n    \\\\with the actual transaction transpiring in the middle:                   \\\\\\n    \\\\                                                                         \\\\\\n    \\\\  1) A buying phase, debiting the sender for total gas and fee, yielding \\\\\\n    \\\\     TX_MAX_CHARGE.                                                      \\\\\\n    \\\\  2) A settlement phase, resuming TX_MAX_CHARGE, and allocating to the   \\\\\\n    \\\\     coinbase account for used gas and fee, and sender account for bal-  \\\\\\n    \\\\     ance (unused gas, if any).\\"\\n\\n    @model [ (property (> total 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account miner))\\n             ;(property conserves-mass) not supported yet\\n           ]\\n\\n    (step (buy-gas sender total))\\n    (step (redeem-gas miner miner-guard sender total))\\n    )\\n\\n  (defun debit:string (account:string amount:decimal)\\n    @doc \\"Debit AMOUNT from ACCOUNT balance\\"\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account account))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0)\\n      \\"debit amount must be positive\\")\\n\\n    (enforce-unit amount)\\n\\n    (require-capability (DEBIT account))\\n    (with-read coin-table account\\n      { \\"balance\\" := balance }\\n\\n      (enforce (<= amount balance) \\"Insufficient funds\\")\\n\\n      (update coin-table account\\n        { \\"balance\\" : (- balance amount) }\\n        ))\\n    )\\n\\n\\n  (defun credit:string (account:string guard:guard amount:decimal)\\n    @doc \\"Credit AMOUNT to ACCOUNT balance\\"\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account account))\\n           ]\\n\\n    (validate-account account)\\n\\n    (enforce (> amount 0.0) \\"credit amount must be positive\\")\\n    (enforce-unit amount)\\n\\n    (require-capability (CREDIT account))\\n    (with-default-read coin-table account\\n      { \\"balance\\" : 0.0, \\"guard\\" : guard }\\n      { \\"balance\\" := balance, \\"guard\\" := retg }\\n      ; we don\'t want to overwrite an existing guard with the user-supplied one\\n      (enforce (= retg guard)\\n        \\"account guards do not match\\")\\n\\n      (write coin-table account\\n        { \\"balance\\" : (+ balance amount)\\n        , \\"guard\\"   : retg\\n        })\\n      ))\\n\\n\\n  (defschema crosschain-schema\\n    @doc \\"Schema for yielded value in cross-chain transfers\\"\\n    receiver:string\\n    receiver-guard:guard\\n    amount:decimal)\\n\\n  (defpact transfer-crosschain:string\\n    ( sender:string\\n      receiver:string\\n      receiver-guard:guard\\n      target-chain:string\\n      amount:decimal )\\n\\n    @model [ (property (> amount 0.0))\\n             (property (valid-account sender))\\n             (property (valid-account receiver))\\n           ]\\n\\n    (step\\n      (with-capability (DEBIT sender)\\n\\n        (validate-account sender)\\n        (validate-account receiver)\\n\\n        (enforce (!= \\"\\" target-chain) \\"empty target-chain\\")\\n        (enforce (!= (at \'chain-id (chain-data)) target-chain)\\n          \\"cannot run cross-chain transfers to the same chain\\")\\n\\n        (enforce (> amount 0.0)\\n          \\"transfer quantity must be positive\\")\\n\\n        (enforce-unit amount)\\n\\n        ;; step 1 - debit delete-account on current chain\\n        (debit sender amount)\\n\\n        (let\\n          ((crosschain-details:object{crosschain-schema}\\n            { \\"receiver\\" : receiver\\n            , \\"receiver-guard\\" : receiver-guard\\n            , \\"amount\\" : amount\\n            }))\\n          (yield crosschain-details target-chain)\\n          )))\\n\\n    (step\\n      (resume\\n        { \\"receiver\\" := receiver\\n        , \\"receiver-guard\\" := receiver-guard\\n        , \\"amount\\" := amount\\n        }\\n\\n        ;; step 2 - credit create account on target chain\\n        (with-capability (CREDIT receiver)\\n          (credit receiver receiver-guard amount))\\n        ))\\n    )\\n\\n\\n  ; --------------------------------------------------------------------------\\n  ; Coin allocations\\n\\n  (defschema allocation-schema\\n    @doc \\"Genesis allocation registry\\"\\n    ;@model [ (invariant (>= balance 0.0)) ]\\n\\n    balance:decimal\\n    date:time\\n    guard:guard\\n    redeemed:bool)\\n\\n  (deftable allocation-table:{allocation-schema})\\n\\n  (defun create-allocation-account\\n    ( account:string\\n      date:time\\n      keyset-ref:string\\n      amount:decimal\\n    )\\n\\n    @doc \\"Add an entry to the coin allocation table. This function \\\\\\n         \\\\also creates a corresponding empty coin contract account \\\\\\n         \\\\of the same name and guard. Requires GENESIS capability. \\"\\n\\n    @model [ (property (valid-account account)) ]\\n\\n    (require-capability (GENESIS))\\n\\n    (validate-account account)\\n    (enforce (>= amount 0.0)\\n      \\"allocation amount must be non-negative\\")\\n\\n    (enforce-unit amount)\\n\\n    (let\\n      ((guard:guard (keyset-ref-guard keyset-ref)))\\n\\n      (create-account account guard)\\n\\n      (insert allocation-table account\\n        { \\"balance\\" : amount\\n        , \\"date\\" : date\\n        , \\"guard\\" : guard\\n        , \\"redeemed\\" : false\\n        })))\\n\\n  (defun release-allocation\\n    ( account:string )\\n\\n    @doc \\"Release funds associated with allocation ACCOUNT into main ledger.   \\\\\\n         \\\\ACCOUNT must already exist in main ledger. Allocation is deactivated \\\\\\n         \\\\after release.\\"\\n    @model [ (property (valid-account account)) ]\\n\\n    (validate-account account)\\n\\n    (with-read allocation-table account\\n      { \\"balance\\" := balance\\n      , \\"date\\" := release-time\\n      , \\"redeemed\\" := redeemed\\n      , \\"guard\\" := guard\\n      }\\n\\n      (let ((curr-time:time (at \'block-time (chain-data))))\\n\\n        (enforce (not redeemed)\\n          \\"allocation funds have already been redeemed\\")\\n\\n        (enforce\\n          (>= curr-time release-time)\\n          (format \\"funds locked until {}. current time: {}\\" [release-time curr-time]))\\n\\n        (enforce-guard guard)\\n\\n        (with-capability (CREDIT account)\\n          (credit account guard balance)\\n\\n          (update allocation-table account\\n            { \\"redeemed\\" : true\\n            , \\"balance\\" : 0.0\\n            })\\n\\n          \\"Allocation successfully released to main ledger\\")\\n    )))\\n\\n)\\n(create-table coin-table)\\n(create-table allocation-table)\\n(enforce\\n  (=\\n    \\"ut_J_ZNkoyaPUEJhiwVeWnkSQn9JT9sQCWKdjjVVrWo\\"\\n    (at \'hash (describe-module \'coin)))\\n  \\"hash mismatch\\")\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: 'true',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDIxMTk3Ng==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJueFNTdDdXU2ZVYXhRTW1ZSWpkYW9VLUVnVUh4WVV0RjQ0OVQzSzJfSXcwIiwiMDVCdGo3ZUJaQlc3by1TYUxvVmhBaWNNVVBaVUJiRzZRVDhfTEFrQ3hIcyJd',
            hash: '05Btj7eBZBW7o-SaLoVhAicMUPZUBbG6QT8_LAkCxHs',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface fungible-v2\\n\\n  \\" Standard for fungible coins and tokens as specified in KIP-0002. \\"\\n\\n   ; ----------------------------------------------------------------------\\n   ; Schema\\n\\n   (defschema account-details\\n    @doc \\"Schema for results of \'account\' operation.\\"\\n    @model [ (invariant (!= \\"\\" sender)) ]\\n\\n    account:string\\n    balance:decimal\\n    guard:guard)\\n\\n\\n   ; ----------------------------------------------------------------------\\n   ; Caps\\n\\n   (defcap TRANSFER:bool\\n     ( sender:string\\n       receiver:string\\n       amount:decimal\\n     )\\n     @doc \\" Managed capability sealing AMOUNT for transfer from SENDER to \\\\\\n          \\\\ RECEIVER. Permits any number of transfers up to AMOUNT.\\"\\n     @managed amount TRANSFER-mgr\\n     )\\n\\n   (defun TRANSFER-mgr:decimal\\n     ( managed:decimal\\n       requested:decimal\\n     )\\n     @doc \\" Manages TRANSFER AMOUNT linearly, \\\\\\n          \\\\ such that a request for 1.0 amount on a 3.0 \\\\\\n          \\\\ managed quantity emits updated amount 2.0.\\"\\n     )\\n\\n   ; ----------------------------------------------------------------------\\n   ; Functionality\\n\\n\\n  (defun transfer:string\\n    ( sender:string\\n      receiver:string\\n      amount:decimal\\n    )\\n    @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n         \\\\ Fails if either SENDER or RECEIVER does not exist.\\"\\n    @model [ (property (> amount 0.0))\\n             (property (!= sender \\"\\"))\\n             (property (!= receiver \\"\\"))\\n             (property (!= sender receiver))\\n           ]\\n    )\\n\\n   (defun transfer-create:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       amount:decimal\\n     )\\n     @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n          \\\\ Fails if SENDER does not exist. If RECEIVER exists, guard \\\\\\n          \\\\ must match existing value. If RECEIVER does not exist, \\\\\\n          \\\\ RECEIVER account is created using RECEIVER-GUARD. \\\\\\n          \\\\ Subject to management by TRANSFER capability.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n            ]\\n     )\\n\\n   (defpact transfer-crosschain:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       target-chain:string\\n       amount:decimal\\n     )\\n     @doc \\" 2-step pact to transfer AMOUNT from SENDER on current chain \\\\\\n          \\\\ to RECEIVER on TARGET-CHAIN via SPV proof. \\\\\\n          \\\\ TARGET-CHAIN must be different than current chain id. \\\\\\n          \\\\ First step debits AMOUNT coins in SENDER account and yields \\\\\\n          \\\\ RECEIVER, RECEIVER_GUARD and AMOUNT to TARGET-CHAIN. \\\\\\n          \\\\ Second step continuation is sent into TARGET-CHAIN with proof \\\\\\n          \\\\ obtained from the spv \'output\' endpoint of Chainweb. \\\\\\n          \\\\ Proof is validated and RECEIVER is credited with AMOUNT \\\\\\n          \\\\ creating account with RECEIVER_GUARD as necessary.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n              (property (!= target-chain \\"\\"))\\n            ]\\n     )\\n\\n   (defun get-balance:decimal\\n     ( account:string )\\n     \\" Get balance for ACCOUNT. Fails if account does not exist.\\"\\n     )\\n\\n   (defun details:object{account-details}\\n     ( account: string )\\n     \\" Get an object with details of ACCOUNT. \\\\\\n     \\\\ Fails if account does not exist.\\"\\n     )\\n\\n   (defun precision:integer\\n     ()\\n     \\"Return the maximum allowed decimal precision.\\"\\n     )\\n\\n   (defun enforce-unit:bool\\n     ( amount:decimal )\\n     \\" Enforce minimum precision allowed for transactions.\\"\\n     )\\n\\n   (defun create-account:string\\n     ( account:string\\n       guard:guard\\n     )\\n     \\" Create ACCOUNT with 0.0 balance, with GUARD controlling access.\\"\\n     )\\n\\n   (defun rotate:string\\n     ( account:string\\n       new-guard:guard\\n     )\\n     \\" Rotate guard for ACCOUNT. Transaction is validated against \\\\\\n     \\\\ existing guard before installing new guard. \\"\\n     )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface fungible-v2"',
              continuation: null,
            },
          },
        },
        {
          cursor: 'MDozMDIxMTk3NQ==',
          node: {
            id: 'VHJhbnNhY3Rpb246WyJueFNTdDdXU2ZVYXhRTW1ZSWpkYW9VLUVnVUh4WVV0RjQ0OVQzSzJfSXcwIiwiNDhUMExqQW5TRnBGV3h2dmFQVi1fNkUtQ2pEQVBoV1lVRldidnlmMmxGcyJd',
            hash: '48T0LjAnSFpFWxvvaPV-_6E-CjDAPhWYUFWbvyf2lFs',
            cmd: {
              meta: {
                sender: '',
              },
              payload: {
                code: '"(interface fungible-v1\\n\\n  \\" Standard for fungible coins and tokens as specified in KIP-0002. \\"\\n\\n   ; ----------------------------------------------------------------------\\n   ; Schema\\n\\n   (defschema account-details\\n    @doc \\"Schema for results of \'account\' operation.\\"\\n    @model [ (invariant (!= \\"\\" sender)) ]\\n\\n    account:string\\n    balance:decimal\\n    guard:guard)\\n\\n\\n   ; ----------------------------------------------------------------------\\n   ; Caps\\n\\n   (defcap TRANSFER:bool\\n     ( sender:string\\n       receiver:string\\n       amount:decimal\\n     )\\n     @doc \\" Managed capability sealing AMOUNT for transfer from SENDER to \\\\\\n          \\\\ RECEIVER. Permits any number of transfers up to AMOUNT.\\"\\n     @managed amount TRANSFER-mgr\\n     )\\n\\n   (defun TRANSFER-mgr:decimal\\n     ( managed:decimal\\n       requested:decimal\\n     )\\n     @doc \\" Manages TRANSFER AMOUNT linearly, \\\\\\n          \\\\ such that a request for 1.0 amount on a 3.0 \\\\\\n          \\\\ managed quantity emits updated amount 2.0.\\"\\n     )\\n\\n   ; ----------------------------------------------------------------------\\n   ; Functionality\\n\\n   (defun transfer-create:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       amount:decimal\\n     )\\n     @doc \\" Transfer AMOUNT between accounts SENDER and RECEIVER. \\\\\\n          \\\\ Fails if SENDER does not exist. If RECEIVER exists, guard \\\\\\n          \\\\ must match existing value. If RECEIVER does not exist, \\\\\\n          \\\\ RECEIVER account is created using RECEIVER-GUARD. \\\\\\n          \\\\ Subject to management by TRANSFER capability.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n            ]\\n     )\\n\\n   (defpact transfer-crosschain:string\\n     ( sender:string\\n       receiver:string\\n       receiver-guard:guard\\n       target-chain:string\\n       amount:decimal\\n     )\\n     @doc \\" 2-step pact to transfer AMOUNT from SENDER on current chain \\\\\\n          \\\\ to RECEIVER on TARGET-CHAIN via SPV proof. \\\\\\n          \\\\ TARGET-CHAIN must be different than current chain id. \\\\\\n          \\\\ First step debits AMOUNT coins in SENDER account and yields \\\\\\n          \\\\ RECEIVER, RECEIVER_GUARD and AMOUNT to TARGET-CHAIN. \\\\\\n          \\\\ Second step continuation is sent into TARGET-CHAIN with proof \\\\\\n          \\\\ obtained from the spv \'output\' endpoint of Chainweb. \\\\\\n          \\\\ Proof is validated and RECEIVER is credited with AMOUNT \\\\\\n          \\\\ creating account with RECEIVER_GUARD as necessary.\\"\\n     @model [ (property (> amount 0.0))\\n              (property (!= sender \\"\\"))\\n              (property (!= receiver \\"\\"))\\n              (property (!= sender receiver))\\n              (property (!= target-chain \\"\\"))\\n            ]\\n     )\\n\\n   (defun get-balance:decimal\\n     ( account:string )\\n     \\" Get balance for ACCOUNT. Fails if account does not exist.\\"\\n     )\\n\\n   (defun details:object{account-details}\\n     ( account: string )\\n     \\" Get an object with details of ACCOUNT. \\\\\\n     \\\\ Fails if account does not exist.\\"\\n     )\\n\\n   (defun precision:integer\\n     ()\\n     \\"Return the maximum allowed decimal precision.\\"\\n     )\\n\\n   (defun enforce-unit:bool\\n     ( amount:decimal )\\n     \\" Enforce minimum precision allowed for transactions.\\"\\n     )\\n\\n   (defun create-account:string\\n     ( account:string\\n       guard:guard\\n     )\\n     \\" Create ACCOUNT with 0.0 balance, with GUARD controlling access.\\"\\n     )\\n\\n   (defun rotate:string\\n     ( account:string\\n       new-guard:guard\\n     )\\n     \\" Rotate guard for ACCOUNT. Transaction is validated against \\\\\\n     \\\\ existing guard before installing new guard. \\"\\n     )\\n\\n)\\n"',
              },
            },
            result: {
              badResult: null,
              goodResult: '"Loaded interface fungible-v1"',
              continuation: null,
            },
          },
        },
      ],
    },
  },
};
